##
# @file cli_gen_tool.py
# @author Douglas Quigg (dstroy0 dquigg123@gmail.com)
# @brief InputHandler CLI generation tool
# @version 0.1
# @date 2022-06-10
# @copyright Copyright (c) 2022
from __future__ import absolute_import # easy import pathing
version = 0.1 # save serialization
# Copyright (C) 2022 Douglas Quigg (dstroy0) <dquigg123@gmail.com>

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 3 as published by the Free Software Foundation.

# imports
import os
import sys
import json
import time # logging timestamp
import platform
import datetime
import qdarktheme
from collections import OrderedDict
from PySide6.QtWidgets import (QApplication, QMainWindow, QDialog, QLabel,
                               QVBoxLayout, QFileDialog, QHeaderView, QDialogButtonBox,
                               QTreeWidgetItem, QStyle, QComboBox, QPlainTextEdit,
                               QTableWidget, QTableWidgetItem, QPushButton)
from PySide6.QtCore import (QFile, Qt, QIODevice, QTextStream,
                            QByteArray, QDir, QRegularExpression)
from PySide6.QtGui import(QRegularExpressionValidator, QIcon, QTextCursor)

# import classes generated by PySide6 uic
from res.uic.mainWindow import Ui_MainWindow # main window with tabs
from res.uic.commandParametersDialog import Ui_commandParametersDialog # tab two popup dialog box

# dev qol var
# these are here for ease of access, clarity, or both
## The first line of every file generated by this tool.
file_first_line = '/* Generated by InputHandler\'s /InputHandler/cli_gen_tool/cli_gen_tool.py version ' + str(version) + ' */\n'

## Automatically generated file docstring.
file_docs_format_string = """/**
* @file {}
* @author Douglas Quigg (dstroy0 dquigg123@gmail.com)
* @brief {}
* @version {}
* @date {}
*
* @copyright Copyright (c) {}
*/
/*
* Copyright (C) {} Douglas Quigg (dstroy0) <dquigg123@gmail.com>
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* version 3 as published by the Free Software Foundation.
*/"""
## The format list for the docstring.
file_docs_format_list = ['filename_ph',
                         'brief_ph',
                         'version_ph',
                         datetime.date.today(),
                         str(datetime.date.today())[0:4],
                         str(datetime.date.today())[0:4]]

## Command parameters dicts are constructed using keys from this list.
command_parameters_dict_keys_list = ['functionName',
                                     'commandString',
                                     'commandLength',
                                     'parentId',
                                     'commandId',
                                     'commandHasWildcards',
                                     'commandDepth',
                                     'commandSubcommands',
                                     'commandArgumentHandling',
                                     'commandMinArgs',
                                     'commandMaxArgs',
                                     'commandArguments']

## This is used to create the session json.
default_session_structure = {"type":"session",
                             "tool_version":str(version),
                             "opt": { "save_filename": None,
                                      "log_filename": None,
                                      "recent_files": {},
                                      "input_config_file_path": "",
                                      "output_dir": "",
                                      "window_size": ""}}

## This dict contains all pertinent information about a CLI, widget objects are created at runtime.
command_line_interface_options_structure = {'type':'cli options',
                                            'var': {'num_commands': 0,
                                                    'tool_version':str(version)},
                                            'commands': {},
                                            'config':{'file_lines':[],
                                                      'tree':{'root':'',
                                                              'parents':{},
                                                              'items':{'library settings':{},
                                                                       'progmem settings':{},                            
                                                                       'debug methods':{},
                                                                       'optional methods':{}}}},
                                            'process output':{'var':{'buffer_size':0},
                                                              'tree':{'root':'',
                                                                      'items':{}}},
                                            'process parameters':{'var':{'process name':'',
                                                                         'end of line characters':'\r\n',
                                                                         'input control char sequence':'##',
                                                                         'wildcard char':'*',
                                                                         'data delimiter sequences':{0:' ',1:','},
                                                                         'start stop data delimiter sequences':{0:'\"',1:'\"'}},
                                                                  'tree':{'root':'',
                                                                          'parents':{},
                                                                          'items':{'data delimiter sequences':{'QTreeWidgetItem':'',
                                                                                                               'QTableWidget':'',
                                                                                                               'QTableWidgetItems':{'add row button':'',
                                                                                                                                    'remove row buttons':{'items':{},
                                                                                                                                                          'buttons':{}}}},
                                                                                   'start stop data delimiter sequences':{'QTreeWidgetItem':'',
                                                                                                                          'QTableWidget':'',
                                                                                                                          'QTableWidgetItems':{'add row button':'',
                                                                                                                                               'remove row buttons':{'items':{},
                                                                                                                                                                     'buttons':{}}}}}}}}

## Acceptable command argument types.
command_arg_types_list = ['UINT8_T',
                          'UINT16_T',
                          'UINT32_T',
                          'INT16_T',
                          'FLOAT',
                          'CHAR',
                          'STARTSTOP',
                          'NOTYPE']

## This dict is ordered to preserve insert order for code preview display. 
generated_filename_dict = OrderedDict()
## This dict contains all generated files and associated widgets.
generated_filename_dict = {'config.h':{'filename':'',
                                       'file_lines_list':[],
                                       'tree_item':{},
                                       'contents_item':{},
                                       'text_widget':{0:'',1:''}},
                           'setup.h':{'filename':'',
                                      'file_lines_list':[],
                                      'tree_item':{},
                                      'contents_item':{},
                                      'text_widget':{0:'',1:''}},
                           'parameters.h':{'filename':'',
                                           'file_lines_list':[],
                                           'tree_item':{},
                                           'contents_item':{},
                                           'text_widget':{0:'',1:''}},
                           'functions.h':{'filename':'',
                                          'file_lines_list':[],
                                          'tree_item':{},
                                          'contents_item':{},
                                          'text_widget':{0:'',1:''}},
                           'functions.cpp':{'filename':'',
                                            'file_lines_list':[],
                                            'tree_item':{},
                                            'contents_item':{},
                                            'text_widget':{0:'',1:''}}}

## The line in /InputHandler/src/config/config.h that boolean define fields start.
config_file_boolean_define_fields_line_start = 72

## This offsets code preview line display; Positive values move text lines down, Negative values move text lines up.
code_preview_text_line_offset = 4
# end dev qol var


## This is the main display window
#
# MainWindow is the parent of all process subwindows (MainWindow is noninteractable when any of its child popups are active)
class MainWindow(QMainWindow):
    ## The constructor.
    def __init__(self, parent=None):
        super().__init__(parent)
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        
        # pathing                
        path = QDir()
        path.cdUp()
        self.lib_root_path = path.currentPath()
        # /InputHandler/src/config/config.h
        self.default_lib_config_path = self.lib_root_path + "/src/config/config.h"
        # /InputHandler/cli_gen_tool/cli_gen_tool.json
        self.cli_gen_tool_json_path = self.lib_root_path + "/cli_gen_tool/cli_gen_tool.json"
                
        # MainWindow icon        
        window_icon_path = self.lib_root_path + "/docs/img/Logolarge.png"        
        self.setWindowIcon(QIcon(window_icon_path))
        # init param popup dialog    
        self.ui.commandParameters = QDialog(self)
        # blue circle question icon
        pixmapapi = QStyle.StandardPixmap.SP_MessageBoxQuestion
        icon = self.style().standardIcon(pixmapapi)
        self.messageBoxQuestionIcon = icon                               
        self.ui.commandParameters.setWindowIcon(self.messageBoxQuestionIcon)
        self.ui.commandParameters.dlg = Ui_commandParametersDialog()
        self.ui.commandParameters.dlg.setupUi(self.ui.commandParameters)        
        self.ui.commandParameters.setMaximumSize(0,0)                            
        
        # MainWindow var
        self.docs = ''
        self.format_docstring = file_docs_format_string
        self.file_first_line = file_first_line
        self.docs_format_list = file_docs_format_list
        self.docs_filename = self.docs_format_list[0]
        self.docs_brief = self.docs_format_list[1]
        self.docs_version = self.docs_format_list[2]                
                        
        # command parameters dict keys list
        self.commandParametersKeys = command_parameters_dict_keys_list
                
        # default settings dict to regen cli_gen_tool.json if it becomes corrupt
        self.defaultGuiOpt = default_session_structure
        
        # cli opt db
        self.cliOpt = command_line_interface_options_structure
        # session db 
        self.session = self.defaultGuiOpt        
        # code preview db        
        self.code_preview_dict = {'files':generated_filename_dict}
        
        # load cli_gen_tool (session) json if exists, else use default options
        self.session = self.load_cli_gen_tool_json(self.cli_gen_tool_json_path)        
        # print pretty session json
        # session json contains only serializable items, safe to print
        print(json.dumps(self.session, indent=4))        
        
        # parse config file
        self.parse_config_header_file(self.session['opt']['input_config_file_path'])                        

        # icons        
        self.ui.fileDialogContentsViewIcon = self.get_icon(QStyle.StandardPixmap.SP_FileDialogContentsView)        
        self.ui.messageBoxCriticalIcon = self.get_icon(QStyle.StandardPixmap.SP_MessageBoxCritical)        
        self.ui.fileIcon = self.get_icon(QStyle.StandardPixmap.SP_FileIcon)                
        self.ui.commandLinkIcon = self.get_icon(QStyle.StandardPixmap.SP_CommandLink)        
        self.ui.trashIcon = self.get_icon(QStyle.StandardPixmap.SP_TrashIcon)      
        # end MainWindow var
        
        # MainWindow actions        
        self.mainwindow_menu_bar_actions_setup()
        self.mainwindow_button_actions_setup()
        # end MainWindow actions
                                        
        # tab 1
        # settings_tree widget setup        
        self.build_lib_settings_tree()        
        
        # code preview trees       
        self.build_code_preview_tree()      
                
        # uncomment to print self.cliOpt as pretty json
        # print(json.dumps(self.cliOpt, indent=4, sort_keys=False, default=lambda o: 'object'))
        
        # tab 2        
        # command parameters dialog box setup
        cmd_dlg = self.ui.commandParameters.dlg
        # This dict contains regexp strings and int limits for user input
        # the values are placeholder values and will change on user interaction
        cmd_dlg.validatorDict = {'functionName':"^([a-zA-Z_])+$",
                                 'commandString':"^([a-zA-Z_*])+$",
                                 'commandParentId':"^([0-9])+$",
                                 'commandId':"^([0-9])+$",
                                 'commandDepth':255,
                                 'commandSubcommands':255,
                                 'commandMinArgs':255,
                                 'commandMaxArgs':255
                                }
        # set validators to user preset or defaults
        self.set_command_parameter_validators()
        # user interaction triggers
        self.set_command_parameters_triggers()
                
        cmd_dlg.argumentsPane.setEnabled(False)
        
        # end MainWindow objects
        # end __init__
    
    def set_table_vertical_labels(self, tree, section, rows):
        vertical_label_list = []                
        for i in range(1,rows +1):
            vertical_label_list.append(str(i))
        vertical_label_list.append('')        
        tree['items'][section]['QTableWidget'].setVerticalHeaderLabels(vertical_label_list)
    
    def add_settings_tree_table_row(self, section, tree, table_widget, add_row_button):
        row = table_widget.rowCount()        
        table_widget.removeCellWidget(row,0)
        row = table_widget.rowCount() - 1         
        tree['items'][section]['QTableWidgetItems'][row] = QTableWidgetItem()
        table_widget_item = tree['items'][section]['QTableWidgetItems'][row]
        table_widget_item.setText('')
        table_widget.insertRow(row)
        row = table_widget.rowCount() - 1
        tree['items'][section]['QTableWidgetItems'].update({row:''})
        tree['items'][section]['QTableWidgetItems'][row] = QTableWidgetItem()
        table_widget_item = tree['items'][section]['QTableWidgetItems'][row]
        table_widget.setItem(row,0,table_widget_item)
        table_widget.setCellWidget(row,0,add_row_button)
        self.set_table_vertical_labels(tree,section,row)        
    
    def rem_settings_tree_table_row(self,section,tree,table_widget,add_row_button):
        row = table_widget.rowCount()
        
    
    def add_data_delimiter_row(self):
        print('add data delimiter row')
        section = 'data delimiter sequences'
        tree = (self.cliOpt['process parameters']['tree'])
        table_widget = tree['items']['data delimiter sequences']['QTableWidget']
        add_row_button = tree['items']['data delimiter sequences']['QTableWidgetItems']['add row button']
        self.add_settings_tree_table_row(section,tree,table_widget,add_row_button)
        
    def add_start_stop_data_delimiter_row(self):
        print('add start stop data delimiter row')
        section = 'start stop data delimiter sequences'
        tree = (self.cliOpt['process parameters']['tree'])
        table_widget = tree['items']['start stop data delimiter sequences']['QTableWidget']
        add_row_button = tree['items']['start stop data delimiter sequences']['QTableWidgetItems']['add row button']
        self.add_settings_tree_table_row(section,tree,table_widget,add_row_button)
        
    def rem_data_delimiter_row(self):
        print('rem data delimiter row')
        section = 'data delimiter sequences'
        tree = (self.cliOpt['process parameters']['tree'])
        table_widget = tree['items']['data delimiter sequences']['QTableWidget']
        add_row_button = tree['items']['data delimiter sequences']['QTableWidgetItems']['add row button']
        self.rem_settings_tree_table_row(section,tree,table_widget,add_row_button)
    
    def build_tree_table_widget(self, index, tree, dict_key, dict_key2, columns, add_row_function, remove_row_button=False):                
        tree['parents'][dict_key2] = QTreeWidgetItem(tree['root'], [dict_key2,''])
        tree['items'][dict_key2]['QTreeWidgetItem'] = QTreeWidgetItem(tree['parents'][dict_key2], ['',''])        
        dict_pos = dict_key + ',' + str(index) + ',' + dict_key2
        tree['items'][dict_key2]['QTreeWidgetItem'].setData(4,0,dict_pos)
        tree['items'][dict_key2]['QTreeWidgetItem'].setFlags(tree['items'][dict_key2]['QTreeWidgetItem'].flags() | Qt.ItemIsEditable)
        tree['items'][dict_key2]['QTableWidget'] = QTableWidget(self)                                
        table_widget = tree['items'][dict_key2]['QTableWidget']
        tree['items'][dict_key2]['QTableWidgetItems'].update({'add row button':QPushButton('add delimiter sequence')})                
        table_header = table_widget.horizontalHeader()
        if remove_row_button == True:
            columns += 1
        table_widget.setColumnCount(columns)                           
        for i in range(0,table_widget.columnCount()-1):                        
            table_header.setSectionResizeMode(i, QHeaderView.Stretch)                                    
        if remove_row_button == True:            
            table_header.setSectionResizeMode(columns-1, QHeaderView.ResizeToContents)
        else:
            table_header.setSectionResizeMode(columns-1, QHeaderView.Stretch)        
        row = 0
        for key in self.cliOpt[dict_key]['var'][dict_key2]:
            row = tree['items'][dict_key2]['QTableWidget'].rowCount()
            tree['items'][dict_key2]['QTableWidget'].insertRow(row)                                                       
            tree['items'][dict_key2]['QTableWidgetItems'].update({row:''})
            tree['items'][dict_key2]['QTableWidgetItems'][row] = QTableWidgetItem()
            tree['items'][dict_key2]['QTableWidget'].setItem(row,0,tree['items'][dict_key2]['QTableWidgetItems'][row])                                
            tree['items'][dict_key2]['QTableWidgetItems'][row].setText(self.cliOpt[dict_key]['var'][dict_key2][key])
            if remove_row_button == True:
                remove_row_buttons = tree['items'][dict_key2]['QTableWidgetItems']['remove row buttons']
                remove_row_buttons.update({'buttons':{key:QPushButton()}})
                remove_row_buttons['buttons'][key].setIcon(self.ui.trashIcon)
                remove_row_buttons.update({'items':{key:QTableWidgetItem()}})
                tree['items'][dict_key2]['QTableWidget'].setItem(row,1,remove_row_buttons['items'][key])
                tree['items'][dict_key2]['QTableWidget'].setCellWidget(row,1,remove_row_buttons['buttons'][key])        
        row = tree['items'][dict_key2]['QTableWidget'].rowCount()
        tree['items'][dict_key2]['QTableWidget'].insertRow(row)                                                       
        vertical_label_list = []                
        for i in range(1,row +1):
            vertical_label_list.append(str(i))            
        vertical_label_list.append('')            
        tree['items'][dict_key2]['QTableWidgetItems'].update({row:''})
        tree['items'][dict_key2]['QTableWidgetItems'][row] = QTableWidgetItem()
        tree['items'][dict_key2]['QTableWidget'].setItem(row,0,tree['items'][dict_key2]['QTableWidgetItems'][row])
        tree['items'][dict_key2]['QTableWidget'].setCellWidget(row,0,tree['items'][dict_key2]['QTableWidgetItems']['add row button'])
        tree['items'][dict_key2]['QTreeWidgetItem'].setFirstColumnSpanned(True)    
        tree['items'][dict_key2]['QTableWidget'].setHorizontalHeaderLabels([dict_key2,''])
        tree['items'][dict_key2]['QTableWidget'].setVerticalHeaderLabels(vertical_label_list)        
        self.ui.settings_tree.setItemWidget(tree['items'][dict_key2]['QTreeWidgetItem'],0,tree['items'][dict_key2]['QTableWidget'])
        tree['items'][dict_key2]['QTableWidgetItems']['add row button'].clicked.connect(add_row_function)                        
        tree['items'][dict_key2]['QTableWidget'].itemPressed.connect(self.edit_table_widget_item)
    
    def edit_table_widget_item(self, item):                                                
        print(item)
        current_item = item.currentItem()
        print(current_item)
        item.editItem(current_item)
        
    def build_lib_settings_tree(self):
        settings_tree = self.ui.settings_tree
        settings_tree.setHeaderLabels(("Section","Macro Name", "Type", "Value"))
        settings_tree.header().setSectionResizeMode(0, QHeaderView.Interactive)
        settings_tree.header().setMinimumSectionSize(150)
        settings_tree.header().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        settings_tree.header().setSectionResizeMode(2, QHeaderView.ResizeToContents)
        settings_tree.header().setSectionResizeMode(3, QHeaderView.ResizeToContents)        
        settings_tree.setColumnCount(5)
        settings_tree.setColumnHidden(4, 1)                            
        
        # process output
        tree = (self.cliOpt['process output']['tree'])
        output_buffer_size = self.cliOpt['process output']['var']['buffer_size']
        tree['root'] = QTreeWidgetItem(settings_tree, ['process output',''])
        tree['root'].setIcon(0, self.ui.commandLinkIcon)
        tree['items'] = QTreeWidgetItem(tree['root'], ['','buffer size','bytes',str(output_buffer_size)])
        dict_pos = 'process output,0,buffer size'
        tree['items'].setData(4,0,dict_pos)
        tree['items'].setFlags(tree['items'].flags() | Qt.ItemIsEditable)
        
        # process parameters
        dict_key = 'process parameters'        
        tree = (self.cliOpt[dict_key]['tree'])                        
        tree['root'] = QTreeWidgetItem(self.ui.settings_tree, [dict_key,''])
        tree['root'].setIcon(0, self.ui.commandLinkIcon)                        
        
        # process name option
        column_label_list = ['','process name','plain text','']
        tree['items'].update({'process name':QTreeWidgetItem(tree['root'],column_label_list)})
        dict_pos = 'process parameters,0,process name'
        tree['items']['process name'].setData(4,0,dict_pos)
        tree['items']['process name'].setFlags(tree['items']['process name'].flags() | Qt.ItemIsEditable)        
        
        columns = 1        
        remove_row_button = True
        dict_key2 = 'data delimiter sequences'
        add_row_function = self.add_data_delimiter_row
        self.build_tree_table_widget(1,tree, dict_key, dict_key2, columns, add_row_function, remove_row_button)                
        dict_key2 = 'start stop data delimiter sequences'
        add_row_function = self.add_start_stop_data_delimiter_row
        self.build_tree_table_widget(2,tree, dict_key, dict_key2, columns, add_row_function, remove_row_button)
        
        # config.h
        tree = (self.cliOpt['config']['tree'])                    
        cfg_dict = (self.cliOpt['config']['tree']['items'])
        cfg_path = self.session['opt']['input_config_file_path']
        tree.update({'root':QTreeWidgetItem(settings_tree, [cfg_path,""])})
        tree['root'].setIcon(0, self.ui.fileDialogContentsViewIcon)
        tree['root'].setToolTip(0, cfg_path)        
                       
        # make these parents children of root using the keys from 'cfg_dict'
        for key in cfg_dict:
            tree['parents'].update({key:QTreeWidgetItem(tree['root'], [key,'','',''])})
            
        # populate `settings_tree`
        for key in cfg_dict:
            for item in cfg_dict[key]:
                regexp = QRegularExpression("(\s*[\/][\/]\s*)")
                sub_dict = (cfg_dict[key][item]['fields'])
                match = regexp.match(sub_dict[1])
                # sort out boolean fields                
                if match.hasMatch() and (sub_dict[0] >= config_file_boolean_define_fields_line_start):                                                                                
                    sub_dict.update({4:False})                    
                    obj_name = key+','+str(item)+','+sub_dict[3]
                    item_list = ['line : '+str(sub_dict[0]),sub_dict[3],"Enable/Disable",'']                    
                    sub_dict.update({5:QTreeWidgetItem(tree['parents'][key], item_list)})                    
                    sub_dict[5].setFlags(sub_dict[5].flags() | Qt.ItemIsEditable)                                                        
                    sub_dict[5].setData(4,0,obj_name)
                    sub_dict[6] = QComboBox()                    
                    sub_dict[6].addItem("Disable",'False')
                    sub_dict[6].addItem("Enable",'True')                    
                    sub_dict[6].setObjectName(obj_name)
                    sub_dict[6].setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLengthWithIcon)
                    settings_tree.setItemWidget(sub_dict[5],3,sub_dict[6])                    
                    sub_dict[6].currentIndexChanged.connect(self.settings_tree_combo_box_index_changed)                    
                elif not match.hasMatch() and (sub_dict[0] >= config_file_boolean_define_fields_line_start):                                        
                    sub_dict.update({4:True})                    
                    obj_name = key+','+str(item)+','+sub_dict[3]
                    item_list = ['line : '+str(sub_dict[0]),sub_dict[3],"Enable/Disable",str(sub_dict[4])]
                    sub_dict.update({5:QTreeWidgetItem(tree['parents'][key], item_list)})
                    sub_dict[5].setFlags(sub_dict[5].flags() | Qt.ItemIsEditable)
                    sub_dict[5].setData(4,0,obj_name)                    
                    sub_dict[6] = QComboBox()
                    sub_dict[6].addItem("Enable",'True')                    
                    sub_dict[6].addItem("Disable",'False')                    
                    sub_dict[6].setObjectName(obj_name)
                    sub_dict[6].setSizeAdjustPolicy(QComboBox.AdjustToMinimumContentsLengthWithIcon)
                    settings_tree.setItemWidget(sub_dict[5],3,sub_dict[6])                    
                    sub_dict[6].currentIndexChanged.connect(self.settings_tree_combo_box_index_changed)   
                else:
                    number_field = 0
                    if sub_dict[4] == '':
                        number_field = 0
                    else:
                        number_field = int(sub_dict[4])
                    if number_field <= 255:
                        type_field = "uint8_t" 
                    elif number_field > 255 and number_field <= 65535:
                        type_field = "uint16_t"                    
                    elif number_field > 65535:
                        type_field = "uint32_t"
                    obj_name = key+','+str(item)+','+sub_dict[3]
                    item_list = ['line : '+str(sub_dict[0]),sub_dict[3],type_field,str(number_field)]
                    sub_dict.update({5:QTreeWidgetItem(tree['parents'][key], item_list)})
                    sub_dict[5].setFlags(sub_dict[5].flags() | Qt.ItemIsEditable)         
                    sub_dict[5].setData(4,0,obj_name)
    
        settings_tree.setEditTriggers(self.ui.settings_tree.NoEditTriggers)
        # update cliOpt with new value when editing is complete
        settings_tree.itemChanged.connect(self.settings_tree_edit_complete) 
        # check if user clicked on the column we want them to edit
        settings_tree.itemDoubleClicked.connect(self.check_if_settings_tree_col_editable)
        # check if user hit enter on an item
        settings_tree.itemActivated.connect(self.settings_tree_item_activated)
    # end build_lib_settings_tree()                        
    
    # build code preview trees
    def build_code_preview_tree(self):
        for key in self.code_preview_dict['files']:
                self.code_preview_dict['files'][key]['filename'] = key 
        for tab in range(0,2):            
            if tab == 0:
                tree = (self.ui.codePreview_1)
            else:
                tree = (self.ui.codePreview_2)
            tree.setHeaderLabels(['File', 'Contents'])
            tree.header().setSectionResizeMode(0, QHeaderView.ResizeToContents)
            tree.header().setSectionResizeMode(1, QHeaderView.ResizeToContents)
            tree.setColumnCount(2)                                           
            for key in self.code_preview_dict['files']:
                self.code_preview_dict['files'][key]['tree_item'][tab] = QTreeWidgetItem(tree, [key,''])
                self.code_preview_dict['files'][key]['tree_item'][tab].setIcon(0, self.ui.fileIcon)                
                self.code_preview_dict['files'][key]['text_widget'][tab] = QPlainTextEdit()                
                self.code_preview_dict['files'][key]['text_widget'][tab].setLineWrapMode(QPlainTextEdit.NoWrap)
                self.code_preview_dict['files'][key]['text_widget'][tab].setReadOnly(True)
                self.code_preview_dict['files'][key]['text_widget'][tab].setObjectName(str(key))
                self.code_preview_dict['files'][key]['text_widget'][tab].setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
                self.code_preview_dict['files'][key]['contents_item'][tab] = QTreeWidgetItem(self.code_preview_dict['files'][key]['tree_item'][tab])                                    
                tree.setItemWidget(self.code_preview_dict['files'][key]['contents_item'][tab], 0, self.code_preview_dict['files'][key]['text_widget'][tab])                
                self.code_preview_dict['files'][key]['contents_item'][tab].setFirstColumnSpanned(True)                            
                if key == 'config.h':
                    self.code_preview_dict['files'][key]['file_lines_list'] = self.cliOpt['config']['file_lines']
                    new_line_list = []
                    code_string = ''
                    for line in self.code_preview_dict['files']['config.h']['file_lines_list']:
                        new_line_list.append(line+'\n')
                        code_string = code_string + line + '\n'
                    self.code_preview_dict['files']['config.h']['file_lines_list'] = new_line_list                
                    self.code_preview_dict['files']['config.h']['text_widget'][tab].setPlainText(code_string)                    
        
        self.ui.tabWidget.currentChanged.connect(self.update_code_preview_tree)
    # end build_code_preview_tree()
    
    # refreshes the text in the code preview trees
    def update_code_preview_tree(self, tree_object):
        print('update code preview')
        # update functions
        def update_config_h(tab, tree_object):
            self.code_preview_dict['files']['config.h']['file_lines_list'] = self.cliOpt['config']['file_lines']
            cfg_dict = self.cliOpt['config']['tree']['items']                    
            for key in cfg_dict:                                                
                for item in cfg_dict[key]:                            
                    sub_dict = cfg_dict[key][item]['fields']                            
                    if sub_dict[4] == True or sub_dict[4] == False:
                        val = ''
                    else:
                        val = sub_dict[4]                        
                    line = str(sub_dict[1]) + str(sub_dict[2]) + str(sub_dict[3]) + str(val)
                    self.code_preview_dict['files']['config.h']['file_lines_list'][int(sub_dict[0])] = line
            code_string = ''
            for line in self.code_preview_dict['files']['config.h']['file_lines_list']:
                code_string = code_string + line + '\n'
            text_widget = self.code_preview_dict['files']['config.h']['text_widget'][tab]
            text_widget.clear()                
            text_widget.setPlainText(code_string)
            object_string = ''            
            if tree_object == None:
                object_string = self.sender().objectName()
            else:
                object_string = str(tree_object.data(4,0))                        
            object_list = object_string.strip('\n').split(',')        
            sub_dict = (self.cliOpt['config']['tree']['items'][object_list[0]][int(object_list[1])]['fields'])
            line_num = int(sub_dict[0])
            cursor = QTextCursor(text_widget.document().findBlockByLineNumber(line_num+code_preview_text_line_offset))                                                                                                 
            text_widget.setTextCursor(cursor)
        
        for tab in range(0,2):                                                            
            for key in self.code_preview_dict['files']:                                                             
                if key == 'config.h':                    
                    update_config_h(tab, tree_object)                    
                    
    # end update_code_preview_tree()                    
                                
    # MainWindow actions
    def open_file(self):
        print('open file')
        # inherit from parent QMainWindow (block main window interaction while dialog box is open)
        dlg = QFileDialog(self)
        dlg.setFileMode(QFileDialog.ExistingFile)
        dlg.setNameFilter("Settings json (*.json)")
        dlg.setViewMode(QFileDialog.Detail)
        fileName = ""
        if dlg.exec():
            fileName = dlg.selectedFiles()
        else:
            return  # dialog cancelled
        file = QFile(fileName[0])
        if (not file.open(QIODevice.ReadOnly | QIODevice.Text)):
            return  # TODO error
        data_in = QTextStream(file).readAll()
        file.close()
        self.cliOpt = json.loads(data_in)  # TODO try/except

    def save_file(self):
        print('save file')
        if self.saveFileName == '':
            self.save_file_as()
            return
        file = QFile(self.saveFileName)
        if (not file.open(QIODevice.WriteOnly | QIODevice.Text)):
            return  # TODO error
        out = QByteArray(json.dumps(self.cliOpt,
                         indent=4, sort_keys=True))  # dump pretty json
        file.write(out)
        file.close()

    def save_file_as(self):
        print('save file as')
        # inherit from parent QMainWindow (block main window interaction while dialog box is open)
        dlg = QFileDialog(self)
        fileName = dlg.getSaveFileName(self, "Save file name", "", ".json")
        if fileName[0] == '':
            return  # dialog cancelled
        fqname = fileName[0] + ".json"
        self.saveFileName = fqname
        file = QFile(fqname)
        if (not file.open(QIODevice.WriteOnly | QIODevice.Text)):
            return  # TODO error
        out = QByteArray(json.dumps(self.cliOpt, indent=4,
                         sort_keys=True))  # dump pretty json
        file.write(out)
        file.close()

    # TODO
    def gui_settings(self):
        print('preferences')

    # close gui
    def gui_exit(self):
        sys.exit(app.quit())

    # TODO
    # generate CLI files
    def generate_cli_files(self):
        print('generate cli files')

    def gui_about(self):
        # print('about')
        # inherit from parent QMainWindow (block main window interaction while dialog box is open)
        dlg = QDialog(self)
        dlg.layout = QVBoxLayout()
        dlg.setWindowTitle('About')
        dlg.git_link_label = QLabel()
        dlg.git_link_label.setText(
            "<a href=\"https://github.com/dstroy0/InputHandler\">Link to library git</a>")
        dlg.git_link_label.setAlignment(Qt.AlignCenter)
        dlg.git_link_label.setTextInteractionFlags(Qt.TextBrowserInteraction)
        dlg.git_link_label.setOpenExternalLinks(True)
        dlg.layout.addWidget(dlg.git_link_label)
        dlg.author_credit_label = QLabel()
        dlg.author_credit_label.setText(
            "Library authors:\nDouglas Quigg (dstroy0 dquigg123@gmail.com)\nBrendan Doherty (2bndy5 2bndy5@gmail.com)")
        dlg.author_credit_label.setAlignment(Qt.AlignCenter)
        dlg.layout.addWidget(dlg.author_credit_label)
        dlg.setLayout(dlg.layout)
        dlg.exec()

    def gui_documentation(self):
        os_type = platform.uname().system.lower()  # lowercase os type
        # windows
        if os_type == "windows":
            os.system("start \"\" https://dstroy0.github.io/InputHandler/")
        # macos
        elif os_type == "darwin":
            os.system("open \"\" https://dstroy0.github.io/InputHandler/")
        # linux
        elif os_type == "linux":
            os.system("xdg-open \"\" https://dstroy0.github.io/InputHandler/")
    # end MainWindow actions
    
    # MainWindow buttons
    # tab 1
    # TODO
    def clicked_edit_tab_one(self):
        print('clicked tab 1 edit')
    # TODO

    def clicked_clear_tab_one(self):
        print('clicked tab 1 clear')
    # TODO

    def clicked_default_tab_one(self):
        print('clicked tab 1 default')
    # tab 2
    # TODO

    def clicked_edit_tab_two(self):
        print('clicked tab 2 edit')
    # TODO

    def clicked_new_tab_two(self):
        print('clicked tab 2 new')
    # TODO

    def clicked_delete_tab_two(self):
        print('clicked tab 2 delete')

    def clicked_open_command_settings_menu_tab_two(self):
        print('clicked open command settings menu')        
        self.ui.commandParameters.exec()        
        
    def clicked_command_parameters_buttonbox_ok(self):        
        print('ok')        
        validate_result = self.validate_command_parameters()
        # error
        if validate_result[0] == True:
            return
        validated_result = {}
        validated_result = validate_result[1]
        # get array index
        cmd_idx = self.cliOpt['var']['num_commands']
        # make dict from defined keys
        self.cliOpt['commands'][cmd_idx] = validated_result
        print(self.cliOpt['commands'][cmd_idx])        
        
        # command parameters were accepted, so increment the array index
        self.cliOpt['var']['num_commands'] += 1
        # print object
        print(self.cliOpt['var'])
        self.ui.commandParameters.close()
    
    def clicked_command_parameters_buttonbox_reset(self):        
        print('reset')
        cmd_dlg = (self.ui.commandParameters.dlg)
        cmd_dlg.argumentsPlainTextCSV.clear()
        
    def clicked_command_parameters_buttonbox_cancel(self):        
        print('cancel')
        self.ui.commandParameters.close()
        
    def command_string_text_changed(self):
        cmd_dlg = (self.ui.commandParameters.dlg)
        cmd_dlg.commandLengthLabel.setText(str(len(cmd_dlg.commandString.text())))
    
    def argument_handling_changed(self):
        print('argument handling changed')
        cmd_dlg = (self.ui.commandParameters.dlg)
        if cmd_dlg.commandArgumentHandling.currentIndex() != 0:
            cmd_dlg.argumentsPane.setEnabled(True)
        else:
            cmd_dlg.argumentsPane.setEnabled(False)            
            
    def parse_config_header_file(self, path):
        config_path = ''        
        if path == '':
            path = QDir()
            path.cdUp()
            config_path = path.currentPath() + "/src/config/config.h"
        else:            
            config_path = path
        
        file = open(config_path, 'r')        
        self.cliOpt['config']['file_lines'] = file.readlines()
        file.close()                
        self.cliOpt['config']['file_lines'].insert(0,self.file_first_line)
        self.update_file_docstring('config.h','autogenerated InputHandler library config','1.0')                
        doc_list = self.docs.split('\n')
        doc_list.pop()
        
        for i in range(1,len(doc_list)+1):                        
            self.cliOpt['config']['file_lines'][i] = doc_list[i-1]        
            self.cliOpt['config']['file_lines'][i] = self.cliOpt['config']['file_lines'][i].strip('\n')
        for i in range(0,len(self.cliOpt['config']['file_lines'])):
            self.cliOpt['config']['file_lines'][i] = self.cliOpt['config']['file_lines'][i].rstrip()                                    
        debug_regexp = "(\s*[\/][\/]\s*)(\s*#define\s*)(DEBUG_\S*)"
        opt_method_regexp = "(\s*[\/]*\s*)(\s*#define\s*)(DISABLE_\S*)"
        setting_regexp = "(\s*[\/]*\s*)(\s*#define\s*)(?!\S*PGM_LEN)(UI_\S*\s*)(\d*)"
        progmem_regexp = "(\s*[\/]*\s*)(\s*#define\s*)(UI_\S*PGM_LEN\s*)(\d*)"        
        regexp_dict = {'library settings':setting_regexp,
                       'progmem settings':progmem_regexp,
                       'debug methods':debug_regexp,
                       'optional methods':opt_method_regexp                       
                      }                                     
        index = {'library settings':0,
                 'progmem settings':0,
                 'optional methods':0,
                 'debug methods':0
                }
        
        line_num = 0
        for line in self.cliOpt['config']['file_lines']:
            for key in regexp_dict:
                line_pos = 0
                regexp = QRegularExpression(regexp_dict[key])
                while line_pos != -1:
                    match = regexp.match(line, line_pos)
                    if match.hasMatch():
                        fields = {0:line_num}                        
                        for i in range(1,7):                            
                            if i < regexp.captureCount() + 1:
                                fields.update({i:match.captured(i)})
                            else:
                                fields.update({i:''})
                            
                        line_pos += match.capturedLength()                                                
                        entry = {index[key]:{'fields':fields}}
                        self.cliOpt['config']['tree']['items'][key].update(entry)
                        index[key] += 1   
                    else:
                        break
            line_num += 1
        # print(json.dumps(self.cliOpt['config']['tree']['items'], indent=4, sort_keys=True))
            
    def regex_validator(self, input):
        exp = QRegularExpression(input)
        return QRegularExpressionValidator(exp)       
        
    def load_cli_gen_tool_json(self, path):                
        session = {}
        file = QFile(path)
        if not file.exists():            
            print('cli_gen_tool.json doesn\'t exist, using default options')
            session = self.defaultGuiOpt                        
            session['opt']['input_config_file_path'] = self.default_lib_config_path            
            return session
        if (not file.open(QIODevice.ReadOnly | QIODevice.Text)):
            file.close()            
            print('open cli_gen_tool.json error; using default options')                        
            session = self.defaultGuiOpt            
            session['opt']['input_config_file_path'] = self.default_lib_config_path
            return session
        data_in = QTextStream(file).readAll()
        file.close()                
        try:
            session = json.loads(data_in)
            print("cli_gen_tool.json:", json.dumps(session, indent=4, sort_keys=True), sep='')
            return session
        except (ValueError, RuntimeError, TypeError, NameError) as e:
            print('json corrupt, removing')
            if self.json_except == 1:
                print('unable to read json, app exit')
                app.quit()
            self.json_except = 1
            os.remove(path) # delete corrupt json
            self.write_cli_gen_tool_json(path, self.defaultGuiOpt) # recreate cli_gen_tool.json
            print(e)
            session = self.defaultGuiOpt            
            session['opt']['input_config_file_path'] = self.default_lib_config_path
            return session
    
    def write_cli_gen_tool_json(self, path, db):
        file = QFile(path)
        if (not file.open(QIODevice.WriteOnly | QIODevice.Text)):
                print('Unable to write new cli_gen_tool.json, please check permissions.')
                return -1
        out = QByteArray(json.dumps(db, indent=4, sort_keys=True))  # dump pretty json                        
        err = file.write(out)
        print('write successful')                        
        file.close()
        return err    
    
    def dict_from_csv_args(self):
        args_dict = {}
        args_list = []
        arg_num_list = []
        csv = self.ui.commandParameters.dlg.argumentsPlainTextCSV.toPlainText() + ','                   
        regexp = QRegularExpression("(\"(?:[^\"]|\")*\"|[^,\"\n\r]*)(,|\r?\n|\r)")        
        csv_pos = 0
        i = 0
        while csv_pos != -1:
            match = regexp.match(csv, csv_pos)            
            if match.hasMatch():                
                csv_pos += match.capturedLength()
                if (match.captured().upper().strip(',')) in command_arg_types_list:
                    arg_num_list.append(i)
                    i = i + 1
                    args_list.append(match.captured().upper().strip(','))
            else:
                break        
        args_dict = dict(zip(arg_num_list, args_list[:-1]))             
        return args_dict

    def csv_button(self):
        print(self.sender().objectName())
        test_string = self.sender().objectName()        
        if test_string == 'add8bituint':                        
            self.append_to_arg_csv('UINT8_T,')
        elif test_string == 'add16bituint':                        
            self.append_to_arg_csv('UINT16_T,')
        elif test_string == 'add32bituint':                        
            self.append_to_arg_csv('UINT32_T,')
        elif test_string == 'add16bitint':                        
            self.append_to_arg_csv('INT16_T,')
        elif test_string == 'addfloat':                        
            self.append_to_arg_csv('FLOAT,')
        elif test_string == 'addchar':                        
            self.append_to_arg_csv('CHAR,')
        elif test_string == 'addstartstop':                        
            self.append_to_arg_csv('STARTSTOP,')
        elif test_string == 'addnotype':                        
            self.append_to_arg_csv('NOTYPE,')
        elif test_string == ('rem' or 'rem1' or 'rem2' or 'rem3' or
                             'rem4' or 'rem5' or 'rem6' or 'rem7'):
            self.rem_from_arg_csv()
    
    def append_to_arg_csv(self, string):
        text = self.ui.commandParameters.dlg.argumentsPlainTextCSV
        cursor = QTextCursor()
        text.moveCursor(cursor.End)
        text.insertPlainText(string)
        text.moveCursor(cursor.End)
    
    def rem_from_arg_csv(self):
        arg_dict = self.dict_from_csv_args()        
        text = self.ui.commandParameters.dlg.argumentsPlainTextCSV
        text.clear()        
        arg_text = ''
        arg_list = list(arg_dict.values())        
        for index in range(len(arg_list)-1):            
            arg_text = arg_text + arg_list[index] + ','
        text.insertPlainText(arg_text)
            
    def update_settings_tree_type_field_text(self, item):                            
        object_string = str(item.data(4,0))                        
        object_list = object_string.strip('\n').split(',')        
        sub_dict = (self.cliOpt['config']['tree']['items'][object_list[0]][int(object_list[1])]['fields'])         
        number_field = int(sub_dict[4])        
        if number_field <= 255:
            type_field = "uint8_t"            
            sub_dict[5].setToolTip(2, '')             
        elif number_field > 255 and number_field <= 65535:
            type_field = "uint16_t*"
            sub_dict[5].setToolTip(2, 'The compiler will warn you about this type change')            
        elif number_field > 65535:
            type_field = "uint32_t*"
            sub_dict[5].setToolTip(2, 'The compiler will warn you about this type change')            
        sub_dict[5].setText(2, type_field)                                        
    
    def settings_tree_combo_box_index_changed(self, index):
        object_string = self.sender().objectName()
        object_list = object_string.strip('\n').split(',')
        object_list[1] = int(object_list[1])        
        sub_dict = (self.cliOpt['config']['tree']['items'][object_list[0]][object_list[1]]['fields'])                
        if sub_dict[6].currentText() == 'Enable':
            sub_dict[1] = '       '
            sub_dict[4] = True
            print(sub_dict[3].strip('\n'),'enabled')
        elif sub_dict[6].currentText() == 'Disable':
            sub_dict[1] = '    // '
            sub_dict[4] = False        
            print(sub_dict[3].strip('\n'),'disabled')
        print('self.cliOpt[\'config\'][\'tree\'][\'items\'][\'{}\'][{}][\'fields\']:'.format(object_list[0],object_list[1]),json.dumps(sub_dict,indent=4,sort_keys=False, default=lambda o: 'object'))
        self.update_code_preview_tree(None)
    
    def settings_tree_item_activated(self, item):
        print('settings tree item activated')        
        self.edit_settings_tree_item(item)
        
    def check_if_settings_tree_col_editable(self, item, column):
        # allow the third column to be editable
        if column == 3:
            self.edit_settings_tree_item(item)
    
    # this is called any time an item changes; any time any column edits take place on settings tree, user or otherwise
    def settings_tree_edit_complete(self, item, col):                        
        if col != 3:
            return                           
        object_string = str(item.data(4,0))                        
        object_list = object_string.strip('\n').split(',')
        if len(object_list) < 2:
            return                
        object_list[1] = int(str(object_list[1]))
        # process output
        if object_list[0] == 'process output':
            print('edited buffer size')
            return
        if object_list[0] == 'process parameters':
            print('edited a process parameter')
            return
        # config.h
        sub_dict = (self.cliOpt['config']['tree']['items'][object_list[0]][object_list[1]]['fields'])                              
        val = str(item.data(3,0))
        tmp = ''
        if val == 'enabled':
            tmp = True
        elif val == 'disabled':
            tmp = False
        else:
            if val == '':
                tmp = 0
            else:
                tmp = int(val)
        if tmp == sub_dict[4]:
            return
        # update the config dict
        sub_dict[4] = tmp 
        self.update_settings_tree_type_field_text(item)
        self.update_code_preview_tree(item)                
        print('self.cliOpt[\'config\'][\'tree\'][\'items\'][\'{}\'][{}][\'fields\']:'.format(object_list[0],object_list[1]),json.dumps(sub_dict,indent=4,sort_keys=False, default=lambda o: 'object'))        
    
    def edit_settings_tree_item(self, item):                                
        widget_present = self.ui.settings_tree.itemWidget(item,0)
        if widget_present != None:
            print(item)
            self.edit_table_widget_item(widget_present)
            return
        object_string = str(item.data(4,0))  
        object_string = object_string.strip()                              
        object_list = object_string.split(',')                        
        print(object_string)
        print('selected ',object_list[2],' in ', object_list[0],' at index ',object_list[1],' current value ',item.data(3,0),sep='')
        self.ui.settings_tree.editItem(item,3)
        
    def validate_command_parameters(self):
        error_list = []
        cmd_dlg = (self.ui.commandParameters.dlg)
        settings_to_validate = dict.fromkeys(self.commandParametersKeys, None)
        settings_to_validate['functionName'] = cmd_dlg.functionName.text()
        settings_to_validate['commandString'] = cmd_dlg.commandString.text()
        settings_to_validate['commandLength'] = len(settings_to_validate['commandString'])
        settings_to_validate['parentId'] = cmd_dlg.commandParentId.text()
        settings_to_validate['commandId'] = cmd_dlg.commandId.text()
        settings_to_validate['commandHasWildcards'] = cmd_dlg.commandHasWildcards.isChecked()
        settings_to_validate['commandDepth'] = cmd_dlg.commandDepth.text()
        settings_to_validate['commandSubcommands'] = cmd_dlg.commandSubcommands.text()
        settings_to_validate['commandArgumentHandling'] = cmd_dlg.commandArgumentHandling.currentIndex()
        settings_to_validate['commandMinArgs'] = cmd_dlg.commandMinArgs.text()
        settings_to_validate['commandMaxArgs'] = cmd_dlg.commandMaxArgs.text() 
        # err is the error sentinel
        err = False
        if settings_to_validate['functionName'] == '':            
            error_list.append('\'Function name\' cannot be empty')
            err = True
        if settings_to_validate['commandString'] == '':            
            error_list.append('\'Command string\' cannot be empty')
            err = True
        if int(settings_to_validate['commandLength']) == 0:            
            error_list.append('\'Command length\' cannot be zero')
            err = True
        if settings_to_validate['parentId'] == '':            
            error_list.append('\'Parent id\' cannot be blank')
            err = True
        elif int(settings_to_validate['parentId']) > 65535:            
            error_list.append('\'Parent id\' cannot be greater than 65535')
            err = True
        if settings_to_validate['commandId'] == '':            
            error_list.append('\'Command id\' cannot be blank')
            err = True
        elif int(settings_to_validate['commandId']) > 65535:            
            error_list.append('\'Command id\' cannot be greater than 65535')
            err = True
        if settings_to_validate['commandDepth'] == '':            
            error_list.append('\'Command depth\' cannot be blank')
            err = True
        elif int(settings_to_validate['commandDepth']) > 255:            
            error_list.append('\'Command depth\' cannot be greater than 255')
            err = True
        if settings_to_validate['commandSubcommands'] == '':            
            error_list.append('\'Subcommands\' cannot be blank')
            err = True            
        elif int(settings_to_validate['commandSubcommands']) > 255:            
            error_list.append('\'Subcommands\'; Command cannot have more than 255 subcommands')
            err = True
        arg_handling_idx = int(settings_to_validate['commandArgumentHandling'])
        if arg_handling_idx == 0:
            settings_to_validate['commandArguments'] = {0: 'NO_ARGS'}
        elif  arg_handling_idx == 1:                                        
            # single argument
            tmp = self.dict_from_csv_args()
            if tmp[0] == '':
                err = True                
                error_list.append('\'Arguments\' field cannot be blank with current \'Argument Handling\' selection')
            settings_to_validate['commandArguments'] = {0: tmp[0]}
        elif arg_handling_idx == 2:
            # argument array
            tmp = self.dict_from_csv_args()  
            if tmp[0] == '':
                err = True                
                error_list.append('\'Arguments\' field cannot be blank with current \'Argument Handling\' selection')               
            settings_to_validate['commandArguments'] = tmp            
        print(settings_to_validate)
        print(error_list)
        if err == True:
            self.err_settings_to_validate(error_list)
        return {0:err,1:settings_to_validate}
    
    def err_settings_to_validate(self, error_list):
        dlg = QDialog(self)
        dlg.layout = QVBoxLayout()
        dlg.setWindowTitle('command error')
        dlg.setWindowIcon(self.ui.messageBoxCriticalIcon)
        error_label = QLabel()
        error_text = ''
        for item in error_list:
            error_text += item
            if item != error_list[len(error_list)-1]:
                error_text += '\n'
        error_label.setText(error_text)
        dlg.layout.addWidget(error_label)
        dlg.setLayout(dlg.layout)
        dlg.exec()
    
    def update_file_docstring(self, file, brief, version):
        self.docs_format_list[0] = file
        self.docs_format_list[1] = brief
        self.docs_format_list[2] = version
        self.docs = self.format_docstring.format(*self.docs_format_list)
    
    def set_command_parameter_validators(self):
        cmd_dlg = self.ui.commandParameters.dlg
        # allowed function name char
        cmd_dlg.functionName.setValidator(self.regex_validator("^([a-zA-Z_])+$"))
        # allowed command string char
        cmd_dlg.commandString.setValidator(self.regex_validator("^([a-zA-Z_*])+$"))
        cmd_dlg.commandParentId.setValidator(self.regex_validator("^([0-9])+$"))
        cmd_dlg.commandId.setValidator(self.regex_validator("^([0-9])+$"))
    
        cmd_dlg.commandDepth.setMaximum(255)
        cmd_dlg.commandSubcommands.setMaximum(255)
    
        cmd_dlg.commandMinArgs.setMaximum(255)
        cmd_dlg.commandMaxArgs.setMaximum(255)
        
    def set_command_parameters_triggers(self):
        cmd_dlg = self.ui.commandParameters.dlg
        cmd_dlg.add8bituint.clicked.connect(self.csv_button)
        cmd_dlg.add16bituint.clicked.connect(self.csv_button)
        cmd_dlg.add32bituint.clicked.connect(self.csv_button)
        cmd_dlg.add16bitint.clicked.connect(self.csv_button)
        cmd_dlg.addfloat.clicked.connect(self.csv_button)
        cmd_dlg.addchar.clicked.connect(self.csv_button)
        cmd_dlg.addstartstop.clicked.connect(self.csv_button)
        cmd_dlg.addnotype.clicked.connect(self.csv_button)
        cmd_dlg.rem.clicked.connect(self.csv_button)
        cmd_dlg.rem1.clicked.connect(self.csv_button)
        cmd_dlg.rem2.clicked.connect(self.csv_button)
        cmd_dlg.rem3.clicked.connect(self.csv_button)
        cmd_dlg.rem4.clicked.connect(self.csv_button)
        cmd_dlg.rem5.clicked.connect(self.csv_button)
        cmd_dlg.rem6.clicked.connect(self.csv_button)
        cmd_dlg.rem7.clicked.connect(self.csv_button)
    
        cmd_dlg.buttonBox.button(QDialogButtonBox.Reset).clicked.connect(self.clicked_command_parameters_buttonbox_reset)
        cmd_dlg.buttonBox.accepted.connect(self.clicked_command_parameters_buttonbox_ok)
        cmd_dlg.buttonBox.rejected.connect(self.clicked_command_parameters_buttonbox_cancel)
    
        cmd_dlg.commandArgumentHandling.currentIndexChanged.connect(self.argument_handling_changed)                  
        cmd_dlg.commandString.textChanged.connect(self.command_string_text_changed)

    def get_icon(self, pixmapapi):
        return self.style().standardIcon(pixmapapi)
    
    def mainwindow_menu_bar_actions_setup(self):
        # file menu actions setup
        # file menu
        self.ui.actionOpen.triggered.connect(self.open_file)
        self.ui.actionSave.triggered.connect(self.save_file)
        self.ui.actionSave_As.triggered.connect(self.save_file_as)
        self.ui.actionPreferences.triggered.connect(self.gui_settings)
        self.ui.actionExit.triggered.connect(self.gui_exit)
        # generate menu
        self.ui.actionGenerate_CLI_Files.triggered.connect(self.generate_cli_files)
        # about menu
        self.ui.actionAbout.triggered.connect(self.gui_about)
        self.ui.actionInputHandler_Documentation.triggered.connect(self.gui_documentation) 
        # end file menu actions setup
        
    def mainwindow_button_actions_setup(self):
        # buttons setup
        # tab 1
        self.ui.editButton_1.clicked.connect(self.clicked_edit_tab_one)
        self.ui.clearButton_1.clicked.connect(self.clicked_clear_tab_one)
        self.ui.defaultButton_1.clicked.connect(self.clicked_default_tab_one)
        # tab 2
        # always visible
        self.ui.newButton_2.clicked.connect(self.clicked_new_tab_two)
        self.ui.editButton_2.clicked.connect(self.clicked_edit_tab_two)
        self.ui.deleteButton_2.clicked.connect(self.clicked_delete_tab_two)
        self.ui.openCloseSettingsMenuButton.clicked.connect(self.clicked_open_command_settings_menu_tab_two)                        
        # end buttons setup
        
# loop
if __name__ == "__main__":
    # GUI container
    app = QApplication(sys.argv)
    # GUI styling
    app.setStyleSheet(qdarktheme.load_stylesheet())
    # GUI layout
    window = MainWindow()
    # show GUI
    window.show()
    # exit on user command
    sys.exit(app.exec())

# end of file
