##
# @file cli_gen_tool.py
# @author Douglas Quigg (dstroy0 dquigg123@gmail.com)
# @brief InputHandler CLI generation tool
# @version 0.1
# @date 2022-06-10
# @copyright Copyright (c) 2022
from __future__ import absolute_import

# Copyright (C) 2022 Douglas Quigg (dstroy0) <dquigg123@gmail.com>
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 3 as published by the Free Software Foundation.

# imports
import os
import sys
import json
import time  # logging timestamp
import platform
import qdarktheme
from PySide6.QtWidgets import (
    QApplication,
    QMainWindow,
    QDialog,
    QLabel,
    QVBoxLayout,
    QFileDialog,
    QHeaderView,
    QDialogButtonBox,
    QTreeWidgetItem,
    QStyle,
    QComboBox,
    QPlainTextEdit,    
    QSplashScreen,
)
from PySide6.QtCore import (
    QFile,
    Qt,
    QIODevice,
    QTextStream,
    QByteArray,    
    QRegularExpression,
    QTimer,
)
from PySide6.QtGui import (
    QRegularExpressionValidator,
    QIcon,
    QTextCursor,
    QPixmap,
)

# import classes generated by PySide6 uic
from res.uic.mainWindow import Ui_MainWindow  # main window with tabs
from res.uic.commandParametersDialog import (
    Ui_commandParametersDialog,
)  # tab two popup dialog box

# external class methods
from res.modules.settings_tree_table_methods import SettingsTreeTableMethods
from res.modules.helper_methods import HelperMethods
from res.modules.dev_qol_var import *

## This is the main display window
#
# MainWindow is the parent of all process subwindows (MainWindow is noninteractable when any of its child popups are active)
class MainWindow(QMainWindow, SettingsTreeTableMethods, HelperMethods):
    ## The constructor.
    def __init__(self, parent=None):
        super().__init__(parent)

        # import external methods into this instance of self
        SettingsTreeTableMethods.__init__(self)
        HelperMethods.__init__(self)
        
        # pathing
        self.lib_root_path = lib_root_path
        # /InputHandler/src/config/config.h
        self.default_lib_config_path = self.lib_root_path + "/src/config/config.h"
        # /InputHandler/cli_gen_tool/cli_gen_tool.json
        self.cli_gen_tool_json_path = (
            self.lib_root_path + "/cli_gen_tool/cli_gen_tool.json"
        )
        print("loading CLI generation tool")
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)

        # MainWindow icon
        window_icon_path = self.lib_root_path + "/docs/img/Logolarge.png"
        self.setWindowIcon(QIcon(window_icon_path))
        # init param popup dialog
        self.ui.commandParameters = QDialog(self)
        # blue circle question icon
        self.ui.commandParameters.setWindowIcon(
            self.get_icon(QStyle.StandardPixmap.SP_MessageBoxQuestion)
        )
        self.ui.commandParameters.dlg = Ui_commandParametersDialog()
        self.ui.commandParameters.dlg.setupUi(self.ui.commandParameters)
        self.ui.commandParameters.setMaximumSize(0, 0)

        # MainWindow var
        self.docs = ""
        self.format_docstring = file_docs_format_string
        self.file_first_line = file_first_line
        self.docs_format_list = file_docs_format_list
        self.docs_filename = self.docs_format_list[0]
        self.docs_brief = self.docs_format_list[1]
        self.docs_version = self.docs_format_list[2]

        # command parameters dict keys list
        self.commandParametersKeys = command_parameters_dict_keys_list

        # default settings dict to regen cli_gen_tool.json if it becomes corrupt
        self.defaultGuiOpt = default_session_structure

        # cli opt db
        self.cliOpt = command_line_interface_options_structure
        # session db
        self.session = self.defaultGuiOpt
        # code preview db
        self.code_preview_dict = {"files": generated_filename_dict}

        # load cli_gen_tool (session) json if exists, else use default options
        self.session = self.load_cli_gen_tool_json(self.cli_gen_tool_json_path)
        # print pretty session json
        # session json contains only serializable items, safe to print
        print(json.dumps(self.session, indent=2))

        # parse config file
        self.parse_config_header_file(self.session["opt"]["input_config_file_path"])

        # icons
        self.ui.fileDialogContentsViewIcon = self.get_icon(
            QStyle.StandardPixmap.SP_FileDialogContentsView
        )
        self.ui.messageBoxCriticalIcon = self.get_icon(
            QStyle.StandardPixmap.SP_MessageBoxCritical
        )
        self.ui.fileIcon = self.get_icon(QStyle.StandardPixmap.SP_FileIcon)
        self.ui.commandLinkIcon = self.get_icon(QStyle.StandardPixmap.SP_CommandLink)
        self.ui.trashIcon = self.get_icon(QStyle.StandardPixmap.SP_TrashIcon)
        # end MainWindow var

        # MainWindow actions
        self.mainwindow_menu_bar_actions_setup()
        self.mainwindow_button_actions_setup()
        # end MainWindow actions

        # tab 1
        # settings_tree widget setup
        self.build_lib_settings_tree()

        # code preview trees
        self.build_code_preview_tree()
        self.display_initial_code_preview()

        # uncomment to print self.cliOpt as pretty json
        # print(json.dumps(self.cliOpt, indent=4, sort_keys=False, default=lambda o: 'object'))

        # tab 2
        # command parameters dialog box setup
        cmd_dlg = self.ui.commandParameters.dlg
        # This dict contains regexp strings and int limits for user input
        # the values are placeholder values and will change on user interaction
        cmd_dlg.validatorDict = {
            "functionName": "^([a-zA-Z_])+$",
            "commandString": "^([a-zA-Z_*])+$",
            "commandParentId": "^([0-9])+$",
            "commandId": "^([0-9])+$",
            "commandDepth": 255,
            "commandSubcommands": 255,
            "commandMinArgs": 255,
            "commandMaxArgs": 255,
        }
        # set validators to user preset or defaults
        self.set_command_parameter_validators()
        # user interaction triggers
        self.set_command_parameters_triggers()

        cmd_dlg.argumentsPane.setEnabled(False)

        # end MainWindow objects
        print("CLI generation tool ready.")
        # end __init__

    # TODO save session on close, prompt user to save work if there is any
    def closeEvent(self, event):
        print("Exiting CLI generation tool")
        event.accept()

    def build_lib_settings_tree(self):
        def set_up_child(
            dict_key, tree, index_of_child, var_name, var_type, var_initial_val
        ):
            column_label_list = ["", var_name, var_type, str(repr(var_initial_val))]
            tree["items"].update(
                {var_name: QTreeWidgetItem(tree["root"], column_label_list)}
            )
            dict_pos = dict_key + "," + str(index_of_child) + "," + var_name
            tree["items"][var_name].setData(4, 0, dict_pos)
            tree["items"][var_name].setFlags(
                tree["items"][var_name].flags() | Qt.ItemIsEditable
            )
            index_of_child += 1
            return index_of_child

        settings_tree = self.ui.settings_tree
        settings_tree.setHeaderLabels(("Section", "Macro Name", "Type", "Value"))
        settings_tree.header().setSectionResizeMode(0, QHeaderView.Interactive)
        settings_tree.header().setMinimumSectionSize(150)
        settings_tree.header().setSectionResizeMode(1, QHeaderView.ResizeToContents)
        settings_tree.header().setSectionResizeMode(2, QHeaderView.ResizeToContents)
        settings_tree.header().setSectionResizeMode(3, QHeaderView.ResizeToContents)
        settings_tree.setColumnCount(5)
        settings_tree.setColumnHidden(4, 1)

        # process output
        index_of_child = 0
        dict_key = "process output"
        tree = self.cliOpt[dict_key]["tree"]
        tree["root"] = QTreeWidgetItem(settings_tree, [dict_key, ""])
        tree["root"].setIcon(0, self.ui.commandLinkIcon)
        # process output buffer size option
        var_name = "buffer size"
        var_type = "bytes"
        var_initial_val = self.cliOpt[dict_key]["var"][var_name]
        index_of_child = set_up_child(
            dict_key, tree, index_of_child, var_name, var_type, var_initial_val
        )

        # process parameters
        index_of_child = 0
        dict_key = "process parameters"
        tree = self.cliOpt[dict_key]["tree"]
        tree["root"] = QTreeWidgetItem(self.ui.settings_tree, [dict_key, ""])
        tree["root"].setIcon(0, self.ui.commandLinkIcon)

        # process parameters process name option
        var_name = "process name"
        var_type = "plain text"
        var_initial_val = self.cliOpt[dict_key]["var"][var_name]
        index_of_child = set_up_child(
            dict_key, tree, index_of_child, var_name, var_type, var_initial_val
        )

        # process parameters end of line characters option
        var_name = "end of line characters"
        var_type = "plain text; control char"
        var_initial_val = self.cliOpt[dict_key]["var"][var_name]
        index_of_child = set_up_child(
            dict_key, tree, index_of_child, var_name, var_type, var_initial_val
        )

        # process parameters input control char sequence option
        var_name = "input control char sequence"
        var_type = "plain text; control char"
        var_initial_val = self.cliOpt[dict_key]["var"][var_name]
        index_of_child = set_up_child(
            dict_key, tree, index_of_child, var_name, var_type, var_initial_val
        )

        # process parameters wildcard char option
        var_name = "wildcard char"
        var_type = "plain text; control char"
        var_initial_val = self.cliOpt[dict_key]["var"][var_name]
        index_of_child = set_up_child(
            dict_key, tree, index_of_child, var_name, var_type, var_initial_val
        )

        # process parameters data delimiter sequences option
        columns = 1
        remove_row_button = True
        dict_key2 = "data delimiter sequences"
        add_row_function = self.add_data_delimiter_row
        self.build_tree_table_widget(
            index_of_child,
            tree,
            dict_key,
            dict_key2,
            columns,
            add_row_function,
            remove_row_button,
        )
        index_of_child += 1
        # process parameters start stop delimiter sequences option
        dict_key2 = "start stop data delimiter sequences"
        add_row_function = self.add_start_stop_data_delimiter_row
        self.build_tree_table_widget(
            index_of_child,
            tree,
            dict_key,
            dict_key2,
            columns,
            add_row_function,
            remove_row_button,
        )

        # config.h
        tree = self.cliOpt["config"]["tree"]
        cfg_dict = self.cliOpt["config"]["tree"]["items"]
        cfg_path = self.session["opt"]["input_config_file_path"]
        tree.update({"root": QTreeWidgetItem(settings_tree, [cfg_path, ""])})
        tree["root"].setIcon(0, self.ui.fileDialogContentsViewIcon)
        tree["root"].setToolTip(0, cfg_path)

        # make these parents children of root using the keys from 'cfg_dict'
        for key in cfg_dict:
            tree["parents"].update(
                {key: QTreeWidgetItem(tree["root"], [key, "", "", ""])}
            )

        # populate `settings_tree`
        for key in cfg_dict:
            for item in cfg_dict[key]:
                regexp = QRegularExpression("(\s*[\/][\/]\s*)")
                sub_dict = cfg_dict[key][item]["fields"]
                match = regexp.match(sub_dict[1])
                # sort out boolean fields
                if match.hasMatch() and (
                    sub_dict[0] >= config_file_boolean_define_fields_line_start
                ):
                    sub_dict.update({4: False})
                    obj_name = key + "," + str(item) + "," + sub_dict[3]
                    item_list = [
                        "line : " + str(sub_dict[0]),
                        sub_dict[3],
                        "Enable/Disable",
                        "",
                    ]
                    sub_dict.update(
                        {5: QTreeWidgetItem(tree["parents"][key], item_list)}
                    )
                    sub_dict[5].setFlags(sub_dict[5].flags() | Qt.ItemIsEditable)
                    sub_dict[5].setData(4, 0, obj_name)
                    sub_dict[6] = QComboBox()
                    sub_dict[6].addItem("Disable", "False")
                    sub_dict[6].addItem("Enable", "True")
                    sub_dict[6].setObjectName(obj_name)
                    sub_dict[6].setSizeAdjustPolicy(
                        QComboBox.AdjustToMinimumContentsLengthWithIcon
                    )
                    settings_tree.setItemWidget(sub_dict[5], 3, sub_dict[6])
                    sub_dict[6].currentIndexChanged.connect(
                        self.settings_tree_combo_box_index_changed
                    )
                elif not match.hasMatch() and (
                    sub_dict[0] >= config_file_boolean_define_fields_line_start
                ):
                    sub_dict.update({4: True})
                    obj_name = key + "," + str(item) + "," + sub_dict[3]
                    item_list = [
                        "line : " + str(sub_dict[0]),
                        sub_dict[3],
                        "Enable/Disable",
                        str(sub_dict[4]),
                    ]
                    sub_dict.update(
                        {5: QTreeWidgetItem(tree["parents"][key], item_list)}
                    )
                    sub_dict[5].setFlags(sub_dict[5].flags() | Qt.ItemIsEditable)
                    sub_dict[5].setData(4, 0, obj_name)
                    sub_dict[6] = QComboBox()
                    sub_dict[6].addItem("Enable", "True")
                    sub_dict[6].addItem("Disable", "False")
                    sub_dict[6].setObjectName(obj_name)
                    sub_dict[6].setSizeAdjustPolicy(
                        QComboBox.AdjustToMinimumContentsLengthWithIcon
                    )
                    settings_tree.setItemWidget(sub_dict[5], 3, sub_dict[6])
                    sub_dict[6].currentIndexChanged.connect(
                        self.settings_tree_combo_box_index_changed
                    )
                else:
                    number_field = 0
                    if sub_dict[4] == "":
                        number_field = 0
                    else:
                        number_field = int(sub_dict[4])
                    if number_field <= 255:
                        type_field = "uint8_t"
                    elif number_field > 255 and number_field <= 65535:
                        type_field = "uint16_t"
                    elif number_field > 65535:
                        type_field = "uint32_t"
                    obj_name = key + "," + str(item) + "," + sub_dict[3]
                    item_list = [
                        "line : " + str(sub_dict[0]),
                        sub_dict[3],
                        type_field,
                        str(number_field),
                    ]
                    sub_dict.update(
                        {5: QTreeWidgetItem(tree["parents"][key], item_list)}
                    )
                    sub_dict[5].setFlags(sub_dict[5].flags() | Qt.ItemIsEditable)
                    sub_dict[5].setData(4, 0, obj_name)

        settings_tree.setEditTriggers(self.ui.settings_tree.NoEditTriggers)
        # update cliOpt with new value when editing is complete
        settings_tree.itemChanged.connect(self.settings_tree_edit_complete)
        # check if user clicked on the column we want them to edit
        settings_tree.itemDoubleClicked.connect(
            self.check_if_settings_tree_col_editable
        )
        # check if user hit enter on an item
        settings_tree.itemActivated.connect(self.settings_tree_item_activated)

    # end build_lib_settings_tree()

    # build code preview trees
    def build_code_preview_tree(self):
        for tab in range(0, 2):
            if tab == 0:
                tree = self.ui.codePreview_1
            else:
                tree = self.ui.codePreview_2
            tree.setHeaderLabels(["File", "Contents"])
            tree.header().setSectionResizeMode(0, QHeaderView.ResizeToContents)
            tree.header().setSectionResizeMode(1, QHeaderView.ResizeToContents)
            tree.setColumnCount(2)
            for key in self.code_preview_dict["files"]:
                self.code_preview_dict["files"][key]["tree_item"][
                    tab
                ] = QTreeWidgetItem(tree, [key, ""])
                self.code_preview_dict["files"][key]["tree_item"][tab].setIcon(
                    0, self.ui.fileIcon
                )
                self.code_preview_dict["files"][key]["text_widget"][
                    tab
                ] = QPlainTextEdit()
                self.code_preview_dict["files"][key]["text_widget"][
                    tab
                ].setLineWrapMode(QPlainTextEdit.NoWrap)
                self.code_preview_dict["files"][key]["text_widget"][tab].setReadOnly(
                    True
                )
                self.code_preview_dict["files"][key]["text_widget"][tab].setObjectName(
                    str(key)
                )
                self.code_preview_dict["files"][key]["text_widget"][
                    tab
                ].setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
                self.code_preview_dict["files"][key]["contents_item"][
                    tab
                ] = QTreeWidgetItem(
                    self.code_preview_dict["files"][key]["tree_item"][tab]
                )
                tree.setItemWidget(
                    self.code_preview_dict["files"][key]["contents_item"][tab],
                    0,
                    self.code_preview_dict["files"][key]["text_widget"][tab],
                )
                self.code_preview_dict["files"][key]["contents_item"][
                    tab
                ].setFirstColumnSpanned(True)

    # end build_code_preview_tree()

    

    def set_text_cursor(self, text_widget, tree_object):
        object_string = ""
        if tree_object == None:
            object_string = self.sender().objectName()
        else:
            object_string = str(tree_object.data(4, 0))
            object_list = object_string.strip("\n").split(",")
            sub_dict = self.cliOpt["config"]["tree"]["items"][object_list[0]][
                int(object_list[1])
            ]["fields"]
            line_num = int(sub_dict[0])
            cursor = QTextCursor(
                text_widget.document().findBlockByLineNumber(
                    line_num + code_preview_text_line_offset
                )
            )
            text_widget.setTextCursor(cursor)

    def update_config_h(self, tree_object, place_cursor=False):
        self.code_preview_dict["files"]["config.h"]["file_lines_list"] = self.cliOpt[
            "config"
        ]["file_lines"]
        cfg_dict = self.cliOpt["config"]["tree"]["items"]
        for key in cfg_dict:
            for item in cfg_dict[key]:
                sub_dict = cfg_dict[key][item]["fields"]
                if sub_dict[4] == True or sub_dict[4] == False:
                    val = ""
                else:
                    val = sub_dict[4]
                    line = (
                        str(sub_dict[1])
                        + str(sub_dict[2])
                        + str(sub_dict[3])
                        + str(val)
                    )
                    self.code_preview_dict["files"]["config.h"]["file_lines_list"][
                        int(sub_dict[0])
                    ] = line
            code_string = self.list_to_code_string(
                self.code_preview_dict["files"]["config.h"]["file_lines_list"]
            )
            for tab in range(2):
                text_widget = self.code_preview_dict["files"]["config.h"][
                    "text_widget"
                ][tab]
                text_widget.clear()
                text_widget.setPlainText(code_string)
                if place_cursor == True:
                    self.set_text_cursor(text_widget, tree_object)
        # end update_config_h

    def update_setup_h(self, tree_object, place_cursor=False):
        file_lines = self.generate_docstring_list_for_filename("setup.h")
        file_lines_list = self.code_preview_dict["files"]["setup.h"]["file_lines_list"]
        del file_lines_list[len(file_lines) :]
        file_lines = file_lines + file_lines_list
        code_string = self.list_to_code_string(file_lines)
        for tab in range(2):
            text_widget = self.code_preview_dict["files"]["setup.h"]["text_widget"][tab]
            text_widget.clear()
            text_widget.setPlainText(code_string)
            if place_cursor == True:
                self.set_text_cursor(text_widget, tree_object)

    # refreshes the text in the code preview trees
    def update_code_preview_tree(self, tree_object):
        print("update code preview")
        # update widgets
        for key in self.code_preview_dict["files"]:
            if key == "config.h":
                self.update_config_h(tree_object, True)
            if key == "setup.h":
                self.update_setup_h(tree_object, True)

    def display_initial_code_preview(self):
        self.update_config_h(None, False)
        self.update_setup_h(None, False)

    # end update_code_preview_tree()
    

    # MainWindow actions
    def open_file(self):
        print("open file")
        # inherit from parent QMainWindow (block main window interaction while dialog box is open)
        dlg = QFileDialog(self)
        dlg.setFileMode(QFileDialog.ExistingFile)
        dlg.setNameFilter("Settings json (*.json)")
        dlg.setViewMode(QFileDialog.Detail)
        fileName = ""
        if dlg.exec():
            fileName = dlg.selectedFiles()
        else:
            return  # dialog cancelled
        file = QFile(fileName[0])
        if not file.open(QIODevice.ReadOnly | QIODevice.Text):
            self.create_popup_dialog_box(
                "File read error.", "Error", self.ui.messageBoxCriticalIcon
            )
            return  # file read error
        data_in = QTextStream(file).readAll()
        file.close()
        data_in_dict = {}
        err = False
        try:
            data_in_dict = json.loads(data_in)
        except:
            print("json encoding error")
            err = True
        try:
            if data_in_dict["type"] != "cli options":
                print("json type error")
        except:
            print("json key error")
            err = True
        if err == True:
            return  # error flag set
        else:
            self.cliOpt = json.loads(data_in)
            print("CLI options json loaded.")

    def save_file(self):
        print("save file")
        if self.saveFileName == "":
            self.save_file_as()
            return
        file = QFile(self.saveFileName)
        if not file.open(QIODevice.WriteOnly | QIODevice.Text):
            self.create_popup_dialog_box(
                "Save file error.", "Error", self.ui.messageBoxCriticalIcon
            )
            return  # error

        out = QByteArray(
            json.dumps(self.cliOpt, indent=4, sort_keys=True)
        )  # dump pretty json
        file.write(out)
        file.close()

    

    def save_file_as(self):
        print("save file as")
        # inherit from parent QMainWindow (block main window interaction while dialog box is open)
        dlg = QFileDialog(self)
        fileName = dlg.getSaveFileName(self, "Save file name", "", ".json")
        if fileName[0] == "":
            return  # dialog cancelled
        fqname = fileName[0] + ".json"
        self.saveFileName = fqname
        file = QFile(fqname)
        if not file.open(QIODevice.WriteOnly | QIODevice.Text):
            return  # TODO error
        out = QByteArray(
            json.dumps(self.cliOpt, indent=4, sort_keys=True)
        )  # dump pretty json
        file.write(out)
        file.close()

    # TODO
    def gui_settings(self):
        print("preferences")

    # close gui
    def gui_exit(self):
        sys.exit(app.quit())

    # TODO
    # generate CLI files
    def generate_cli_files(self):
        print("generate cli files")

    def gui_about(self):
        # print('about')
        # inherit from parent QMainWindow (block main window interaction while dialog box is open)
        dlg = QDialog(self)
        dlg.layout = QVBoxLayout()
        dlg.setWindowTitle("About")
        dlg.git_link_label = QLabel()
        dlg.git_link_label.setText(
            '<a href="https://github.com/dstroy0/InputHandler">Link to library git</a>'
        )
        dlg.git_link_label.setAlignment(Qt.AlignCenter)
        dlg.git_link_label.setTextInteractionFlags(Qt.TextBrowserInteraction)
        dlg.git_link_label.setOpenExternalLinks(True)
        dlg.layout.addWidget(dlg.git_link_label)
        dlg.author_credit_label = QLabel()
        dlg.author_credit_label.setText(
            "Library authors:\nDouglas Quigg (dstroy0 dquigg123@gmail.com)\nBrendan Doherty (2bndy5 2bndy5@gmail.com)"
        )
        dlg.author_credit_label.setAlignment(Qt.AlignCenter)
        dlg.layout.addWidget(dlg.author_credit_label)
        dlg.setLayout(dlg.layout)
        dlg.exec()

    def gui_documentation(self):
        os_type = platform.uname().system.lower()  # lowercase os type
        # windows
        if os_type == "windows":
            os.system('start "" https://dstroy0.github.io/InputHandler/')
        # macos
        elif os_type == "darwin":
            os.system('open "" https://dstroy0.github.io/InputHandler/')
        # linux
        elif os_type == "linux":
            os.system('xdg-open "" https://dstroy0.github.io/InputHandler/')

    # end MainWindow actions

    # MainWindow buttons
    # tab 1
    # TODO
    def clicked_edit_tab_one(self):
        print("clicked tab 1 edit")

    # TODO

    def clicked_clear_tab_one(self):
        print("clicked tab 1 clear")

    # TODO

    def clicked_default_tab_one(self):
        print("clicked tab 1 default")

    # tab 2
    # TODO

    def clicked_edit_tab_two(self):
        print("clicked tab 2 edit")

    # TODO

    def clicked_new_tab_two(self):
        print("clicked tab 2 new")

    # TODO

    def clicked_delete_tab_two(self):
        print("clicked tab 2 delete")

    def clicked_open_command_settings_menu_tab_two(self):
        print("clicked open command settings menu")
        self.ui.commandParameters.exec()

    def clicked_command_parameters_buttonbox_ok(self):
        print("ok")
        validate_result = self.validate_command_parameters()
        # error
        if validate_result[0] == True:
            return
        validated_result = {}
        validated_result = validate_result[1]
        # get array index
        cmd_idx = self.cliOpt["var"]["num_commands"]
        # make dict from defined keys
        self.cliOpt["commands"][cmd_idx] = validated_result
        print(self.cliOpt["commands"][cmd_idx])

        # command parameters were accepted, so increment the array index
        self.cliOpt["var"]["num_commands"] += 1
        # print object
        print(self.cliOpt["var"])
        self.ui.commandParameters.close()

    def clicked_command_parameters_buttonbox_reset(self):
        print("reset")
        cmd_dlg = self.ui.commandParameters.dlg
        cmd_dlg.argumentsPlainTextCSV.clear()

    def clicked_command_parameters_buttonbox_cancel(self):
        print("cancel")
        self.ui.commandParameters.close()

    def command_string_text_changed(self):
        cmd_dlg = self.ui.commandParameters.dlg
        cmd_dlg.commandLengthLabel.setText(str(len(cmd_dlg.commandString.text())))

    def argument_handling_changed(self):
        print("argument handling changed")
        cmd_dlg = self.ui.commandParameters.dlg
        if cmd_dlg.commandArgumentHandling.currentIndex() != 0:
            cmd_dlg.argumentsPane.setEnabled(True)
        else:
            cmd_dlg.argumentsPane.setEnabled(False)

    def parse_config_header_file(self, path):
        config_path = ""
        if path == "":
            config_path = self.default_lib_config_path
        else:
            config_path = path
        file_line_list = []
        config_file = open(config_path, "r")
        file_line_list = config_file.readlines()
        config_file.close()
        remove_number_of_lines = 16
        if "autogenerated" in file_line_list[0]:
            remove_number_of_lines = 17
        del file_line_list[0:remove_number_of_lines]
        for line in range(len(file_line_list)):
            file_line_list[line] = file_line_list[line].rstrip()
        self.cliOpt["config"]["file_lines"] = self.generate_docstring_list_for_filename(
            "config.h"
        )
        self.cliOpt["config"]["file_lines"] = (
            self.cliOpt["config"]["file_lines"] + file_line_list
        )

        debug_regexp = "(\s*[\/][\/]\s*)(\s*#define\s*)(DEBUG_\S*)"
        opt_method_regexp = "(\s*[\/]*\s*)(\s*#define\s*)(DISABLE_\S*)"
        setting_regexp = "(\s*[\/]*\s*)(\s*#define\s*)(?!\S*PGM_LEN)(UI_\S*\s*)(\d*)"
        progmem_regexp = "(\s*[\/]*\s*)(\s*#define\s*)(UI_\S*PGM_LEN\s*)(\d*)"
        regexp_dict = {
            "library settings": setting_regexp,
            "progmem settings": progmem_regexp,
            "debug methods": debug_regexp,
            "optional methods": opt_method_regexp,
        }
        index = {
            "library settings": 0,
            "progmem settings": 0,
            "optional methods": 0,
            "debug methods": 0,
        }

        line_num = 0
        for line in self.cliOpt["config"]["file_lines"]:
            for key in regexp_dict:
                line_pos = 0
                regexp = QRegularExpression(regexp_dict[key])
                while line_pos != -1:
                    match = regexp.match(line, line_pos)
                    if match.hasMatch():
                        fields = {0: line_num}
                        for i in range(1, 7):
                            if i < regexp.captureCount() + 1:
                                fields.update({i: match.captured(i)})
                            else:
                                fields.update({i: ""})

                        line_pos += match.capturedLength()
                        entry = {index[key]: {"fields": fields}}
                        self.cliOpt["config"]["tree"]["items"][key].update(entry)
                        index[key] += 1
                    else:
                        break
            line_num += 1
        # print(json.dumps(self.cliOpt['config']['tree']['items'], indent=4, sort_keys=True))

    def regex_validator(self, input):
        exp = QRegularExpression(input)
        return QRegularExpressionValidator(exp)

    def load_cli_gen_tool_json(self, path):
        session = {}
        file = QFile(path)
        if not file.exists():
            print("cli_gen_tool.json doesn't exist, using default options")
            session = self.defaultGuiOpt
            session["opt"]["input_config_file_path"] = self.default_lib_config_path
            return session
        if not file.open(QIODevice.ReadOnly | QIODevice.Text):
            file.close()
            print("open cli_gen_tool.json error; using default options")
            session = self.defaultGuiOpt
            session["opt"]["input_config_file_path"] = self.default_lib_config_path
            return session
        data_in = QTextStream(file).readAll()
        file.close()
        try:
            session = json.loads(data_in)
            print(
                "cli_gen_tool.json:",
                json.dumps(session, indent=4, sort_keys=True),
                sep="",
            )
            return session
        except (ValueError, RuntimeError, TypeError, NameError) as e:
            print("json corrupt, removing")
            if self.json_except == 1:
                print("unable to read json, app exit")
                app.quit()
            self.json_except = 1
            os.remove(path)  # delete corrupt json
            self.write_cli_gen_tool_json(
                path, self.defaultGuiOpt
            )  # recreate cli_gen_tool.json
            print(e)
            session = self.defaultGuiOpt
            session["opt"]["input_config_file_path"] = self.default_lib_config_path
            return session

    def write_cli_gen_tool_json(self, path, db):
        file = QFile(path)
        if not file.open(QIODevice.WriteOnly | QIODevice.Text):
            print("Unable to write new cli_gen_tool.json, please check permissions.")
            return -1
        out = QByteArray(json.dumps(db, indent=4, sort_keys=True))  # dump pretty json
        err = file.write(out)
        print("write successful")
        file.close()
        return err

    def dict_from_csv_args(self):
        args_dict = {}
        args_list = []
        arg_num_list = []
        csv = self.ui.commandParameters.dlg.argumentsPlainTextCSV.toPlainText() + ","
        regexp = QRegularExpression('("(?:[^"]|")*"|[^,"\n\r]*)(,|\r?\n|\r)')
        csv_pos = 0
        i = 0
        while csv_pos != -1:
            match = regexp.match(csv, csv_pos)
            if match.hasMatch():
                csv_pos += match.capturedLength()
                if (match.captured().upper().strip(",")) in command_arg_types_list:
                    arg_num_list.append(i)
                    i = i + 1
                    args_list.append(match.captured().upper().strip(","))
            else:
                break
        args_dict = dict(zip(arg_num_list, args_list[:-1]))
        return args_dict

    def csv_button(self):
        print(self.sender().objectName())
        test_string = self.sender().objectName()
        if test_string == "add8bituint":
            self.append_to_arg_csv("UINT8_T,")
        elif test_string == "add16bituint":
            self.append_to_arg_csv("UINT16_T,")
        elif test_string == "add32bituint":
            self.append_to_arg_csv("UINT32_T,")
        elif test_string == "add16bitint":
            self.append_to_arg_csv("INT16_T,")
        elif test_string == "addfloat":
            self.append_to_arg_csv("FLOAT,")
        elif test_string == "addchar":
            self.append_to_arg_csv("CHAR,")
        elif test_string == "addstartstop":
            self.append_to_arg_csv("STARTSTOP,")
        elif test_string == "addnotype":
            self.append_to_arg_csv("NOTYPE,")
        elif test_string == (
            "rem" or "rem1" or "rem2" or "rem3" or "rem4" or "rem5" or "rem6" or "rem7"
        ):
            self.rem_from_arg_csv()

    def append_to_arg_csv(self, string):
        text = self.ui.commandParameters.dlg.argumentsPlainTextCSV
        cursor = QTextCursor()
        text.moveCursor(cursor.End)
        text.insertPlainText(string)
        text.moveCursor(cursor.End)

    def rem_from_arg_csv(self):
        arg_dict = self.dict_from_csv_args()
        text = self.ui.commandParameters.dlg.argumentsPlainTextCSV
        text.clear()
        arg_text = ""
        arg_list = list(arg_dict.values())
        for index in range(len(arg_list) - 1):
            arg_text = arg_text + arg_list[index] + ","
        text.insertPlainText(arg_text)

    def update_settings_tree_type_field_text(self, item):
        object_string = str(item.data(4, 0))
        object_list = object_string.strip("\n").split(",")
        sub_dict = self.cliOpt["config"]["tree"]["items"][object_list[0]][
            int(object_list[1])
        ]["fields"]
        number_field = int(sub_dict[4])
        if number_field <= 255:
            type_field = "uint8_t"
            sub_dict[5].setToolTip(2, "")
        elif number_field > 255 and number_field <= 65535:
            type_field = "uint16_t*"
            sub_dict[5].setToolTip(
                2, "The compiler will warn you about this type change"
            )
        elif number_field > 65535:
            type_field = "uint32_t*"
            sub_dict[5].setToolTip(
                2, "The compiler will warn you about this type change"
            )
        sub_dict[5].setText(2, type_field)

    def settings_tree_combo_box_index_changed(self, index):
        object_string = self.sender().objectName()
        object_list = object_string.strip("\n").split(",")
        object_list[1] = int(object_list[1])
        sub_dict = self.cliOpt["config"]["tree"]["items"][object_list[0]][
            object_list[1]
        ]["fields"]
        if sub_dict[6].currentText() == "Enable":
            sub_dict[1] = "       "
            sub_dict[4] = True
            print(sub_dict[3].strip("\n"), "enabled")
        elif sub_dict[6].currentText() == "Disable":
            sub_dict[1] = "    // "
            sub_dict[4] = False
            print(sub_dict[3].strip("\n"), "disabled")
        print(
            "self.cliOpt['config']['tree']['items']['{}'][{}]['fields']:".format(
                object_list[0], object_list[1]
            ),
            json.dumps(sub_dict, indent=4, sort_keys=False, default=lambda o: "object"),
        )
        self.update_code_preview_tree(None)

    def settings_tree_item_activated(self, item):
        print("settings tree item activated")
        self.edit_settings_tree_item(item)

    def check_if_settings_tree_col_editable(self, item, column):
        # allow the third column to be editable
        if column == 3:
            self.edit_settings_tree_item(item)

    # this is called any time an item changes; any time any column edits take place on settings tree, user or otherwise
    def settings_tree_edit_complete(self, item, col):
        if col != 3:
            return
        val = str(item.data(3, 0))
        if "'" in val:
            return  # already repr
        object_string = str(item.data(4, 0))
        object_list = object_string.strip("\n").split(",")
        if len(object_list) < 2:
            return
        object_list[1] = int(str(object_list[1]))
        # process output
        if object_list[0] == "process output":
            print("edited buffer size")
            item.setText(3, str(repr(val)))
            return
        if object_list[0] == "process parameters":
            print("edited a process parameter")
            item.setText(3, str(repr(val)))
            return
        # config.h
        sub_dict = self.cliOpt["config"]["tree"]["items"][object_list[0]][
            object_list[1]
        ]["fields"]
        tmp = ""
        if val == "enabled":
            tmp = True
        elif val == "disabled":
            tmp = False
        else:
            if val == "":
                tmp = 0
                item.setText(3, str(repr(tmp)))
            else:
                tmp = int(val)
                item.setText(3, str(repr(tmp)))
        if tmp == sub_dict[4]:
            return
        # update the config dict
        sub_dict[4] = tmp
        self.update_settings_tree_type_field_text(item)
        self.update_code_preview_tree(item)
        print(
            "self.cliOpt['config']['tree']['items']['{}'][{}]['fields']:".format(
                object_list[0], object_list[1]
            ),
            json.dumps(sub_dict, indent=4, sort_keys=False, default=lambda o: "object"),
        )

    def edit_settings_tree_item(self, item):
        widget_present = self.ui.settings_tree.itemWidget(item, 0)
        if widget_present != None:
            print(item)
            self.edit_table_widget_item(widget_present)
            return
        object_string = str(item.data(4, 0))
        object_string = object_string.strip()
        object_list = object_string.split(",")
        print(
            "selected ",
            object_list[2],
            " in ",
            object_list[0],
            " at index ",
            object_list[1],
            " current value ",
            item.data(3, 0),
            sep="",
        )
        self.ui.settings_tree.editItem(item, 3)

    def validate_command_parameters(self):
        error_list = []
        cmd_dlg = self.ui.commandParameters.dlg
        settings_to_validate = dict.fromkeys(self.commandParametersKeys, None)
        settings_to_validate["functionName"] = cmd_dlg.functionName.text()
        settings_to_validate["commandString"] = cmd_dlg.commandString.text()
        settings_to_validate["commandLength"] = len(
            settings_to_validate["commandString"]
        )
        settings_to_validate["parentId"] = cmd_dlg.commandParentId.text()
        settings_to_validate["commandId"] = cmd_dlg.commandId.text()
        settings_to_validate[
            "commandHasWildcards"
        ] = cmd_dlg.commandHasWildcards.isChecked()
        settings_to_validate["commandDepth"] = cmd_dlg.commandDepth.text()
        settings_to_validate["commandSubcommands"] = cmd_dlg.commandSubcommands.text()
        settings_to_validate[
            "commandArgumentHandling"
        ] = cmd_dlg.commandArgumentHandling.currentIndex()
        settings_to_validate["commandMinArgs"] = cmd_dlg.commandMinArgs.text()
        settings_to_validate["commandMaxArgs"] = cmd_dlg.commandMaxArgs.text()
        # err is the error sentinel
        err = False
        if settings_to_validate["functionName"] == "":
            error_list.append("'Function name' cannot be empty")
            err = True
        if settings_to_validate["commandString"] == "":
            error_list.append("'Command string' cannot be empty")
            err = True
        if int(settings_to_validate["commandLength"]) == 0:
            error_list.append("'Command length' cannot be zero")
            err = True
        if settings_to_validate["parentId"] == "":
            error_list.append("'Parent id' cannot be blank")
            err = True
        elif int(settings_to_validate["parentId"]) > 65535:
            error_list.append("'Parent id' cannot be greater than 65535")
            err = True
        if settings_to_validate["commandId"] == "":
            error_list.append("'Command id' cannot be blank")
            err = True
        elif int(settings_to_validate["commandId"]) > 65535:
            error_list.append("'Command id' cannot be greater than 65535")
            err = True
        if settings_to_validate["commandDepth"] == "":
            error_list.append("'Command depth' cannot be blank")
            err = True
        elif int(settings_to_validate["commandDepth"]) > 255:
            error_list.append("'Command depth' cannot be greater than 255")
            err = True
        if settings_to_validate["commandSubcommands"] == "":
            error_list.append("'Subcommands' cannot be blank")
            err = True
        elif int(settings_to_validate["commandSubcommands"]) > 255:
            error_list.append(
                "'Subcommands'; Command cannot have more than 255 subcommands"
            )
            err = True
        arg_handling_idx = int(settings_to_validate["commandArgumentHandling"])
        if arg_handling_idx == 0:
            settings_to_validate["commandArguments"] = {0: "NO_ARGS"}
        elif arg_handling_idx == 1:
            # single argument
            tmp = self.dict_from_csv_args()
            if tmp[0] == "":
                err = True
                error_list.append(
                    "'Arguments' field cannot be blank with current 'Argument Handling' selection"
                )
            settings_to_validate["commandArguments"] = {0: tmp[0]}
        elif arg_handling_idx == 2:
            # argument array
            tmp = self.dict_from_csv_args()
            if tmp[0] == "":
                err = True
                error_list.append(
                    "'Arguments' field cannot be blank with current 'Argument Handling' selection"
                )
            settings_to_validate["commandArguments"] = tmp
        print(settings_to_validate)
        print(error_list)
        if err == True:
            self.err_settings_to_validate(error_list)
        return {0: err, 1: settings_to_validate}

    def err_settings_to_validate(self, error_list):
        dlg = QDialog(self)
        dlg.layout = QVBoxLayout()
        dlg.setWindowTitle("command error")
        dlg.setWindowIcon(self.ui.messageBoxCriticalIcon)
        error_label = QLabel()
        error_text = ""
        for item in error_list:
            error_text += item
            if item != error_list[len(error_list) - 1]:
                error_text += "\n"
        error_label.setText(error_text)
        dlg.layout.addWidget(error_label)
        dlg.setLayout(dlg.layout)
        dlg.exec()

    

    def set_command_parameter_validators(self):
        cmd_dlg = self.ui.commandParameters.dlg
        # allowed function name char
        cmd_dlg.functionName.setValidator(
            self.regex_validator(cmd_dlg.validatorDict["functionName"])
        )
        # allowed command string char
        cmd_dlg.commandString.setValidator(
            self.regex_validator(cmd_dlg.validatorDict["commandString"])
        )
        cmd_dlg.commandParentId.setValidator(
            self.regex_validator(cmd_dlg.validatorDict["commandParentId"])
        )
        cmd_dlg.commandId.setValidator(
            self.regex_validator(cmd_dlg.validatorDict["commandId"])
        )
        cmd_dlg.commandDepth.setMaximum(cmd_dlg.validatorDict["commandDepth"])
        cmd_dlg.commandSubcommands.setMaximum(
            cmd_dlg.validatorDict["commandSubcommands"]
        )
        cmd_dlg.commandMinArgs.setMaximum(cmd_dlg.validatorDict["commandMinArgs"])
        cmd_dlg.commandMaxArgs.setMaximum(cmd_dlg.validatorDict["commandMaxArgs"])

    def set_command_parameters_triggers(self):
        cmd_dlg = self.ui.commandParameters.dlg
        cmd_dlg.add8bituint.clicked.connect(self.csv_button)
        cmd_dlg.add16bituint.clicked.connect(self.csv_button)
        cmd_dlg.add32bituint.clicked.connect(self.csv_button)
        cmd_dlg.add16bitint.clicked.connect(self.csv_button)
        cmd_dlg.addfloat.clicked.connect(self.csv_button)
        cmd_dlg.addchar.clicked.connect(self.csv_button)
        cmd_dlg.addstartstop.clicked.connect(self.csv_button)
        cmd_dlg.addnotype.clicked.connect(self.csv_button)
        cmd_dlg.rem.clicked.connect(self.csv_button)
        cmd_dlg.rem1.clicked.connect(self.csv_button)
        cmd_dlg.rem2.clicked.connect(self.csv_button)
        cmd_dlg.rem3.clicked.connect(self.csv_button)
        cmd_dlg.rem4.clicked.connect(self.csv_button)
        cmd_dlg.rem5.clicked.connect(self.csv_button)
        cmd_dlg.rem6.clicked.connect(self.csv_button)
        cmd_dlg.rem7.clicked.connect(self.csv_button)
        cmd_dlg.buttonBox.button(QDialogButtonBox.Reset).clicked.connect(
            self.clicked_command_parameters_buttonbox_reset
        )
        cmd_dlg.buttonBox.accepted.connect(self.clicked_command_parameters_buttonbox_ok)
        cmd_dlg.buttonBox.rejected.connect(
            self.clicked_command_parameters_buttonbox_cancel
        )
        cmd_dlg.commandArgumentHandling.currentIndexChanged.connect(
            self.argument_handling_changed
        )
        cmd_dlg.commandString.textChanged.connect(self.command_string_text_changed)    

    def mainwindow_menu_bar_actions_setup(self):
        # file menu actions setup
        # file menu
        self.ui.actionOpen.triggered.connect(self.open_file)
        self.ui.actionSave.triggered.connect(self.save_file)
        self.ui.actionSave_As.triggered.connect(self.save_file_as)
        self.ui.actionPreferences.triggered.connect(self.gui_settings)
        self.ui.actionExit.triggered.connect(self.gui_exit)
        # generate menu
        self.ui.actionGenerate_CLI_Files.triggered.connect(self.generate_cli_files)
        # about menu
        self.ui.actionAbout.triggered.connect(self.gui_about)
        self.ui.actionInputHandler_Documentation.triggered.connect(
            self.gui_documentation
        )
        # end file menu actions setup

    def mainwindow_button_actions_setup(self):
        # buttons setup
        # tab 1
        self.ui.editButton_1.clicked.connect(self.clicked_edit_tab_one)
        self.ui.clearButton_1.clicked.connect(self.clicked_clear_tab_one)
        self.ui.defaultButton_1.clicked.connect(self.clicked_default_tab_one)
        # tab 2
        # always visible
        self.ui.newButton_2.clicked.connect(self.clicked_new_tab_two)
        self.ui.editButton_2.clicked.connect(self.clicked_edit_tab_two)
        self.ui.deleteButton_2.clicked.connect(self.clicked_delete_tab_two)
        self.ui.openCloseSettingsMenuButton.clicked.connect(
            self.clicked_open_command_settings_menu_tab_two
        )
        # end buttons setup


# loop
if __name__ == "__main__":
    # GUI container
    app = QApplication(sys.argv)
    # GUI styling
    app.setStyleSheet(qdarktheme.load_stylesheet())
    # app splashscreen
    splash = QSplashScreen()
    splash.setPixmap(QPixmap(lib_root_path + "/docs/img/_Logolarge.png"))
    splash.showMessage(
        "Copyright (c) 2022 Douglas Quigg (dstroy0) <dquigg123@gmail.com>",
        (Qt.AlignHCenter | Qt.AlignBottom),
        Qt.white,
    )
    splash.setWindowFlags(
        splash.windowFlags() | Qt.WindowStaysOnTopHint
    )  # or the windowstaysontophint into QSplashScreen window flags
    splash.show()
    app.processEvents()
    splash.timer = QTimer()
    splash.timer.setSingleShot(True)
    # GUI layout
    window = MainWindow()
    window.show()
    splash.timer.timeout.connect(splash.close)
    splash.timer.start(splashscreen_duration)
    # exit on user command
    sys.exit(app.exec())

# end of file
