##
# @file filestrings.py
# @author Douglas Quigg (dstroy0 dquigg123@gmail.com)
# @brief CLI filestrings
# @version 1.0
# @date 2022-08-02
# @copyright Copyright (c) 2022
# Copyright (C) 2022 Douglas Quigg (dstroy0) <dquigg123@gmail.com>
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# version 3 as published by the Free Software Foundation.

from __future__ import absolute_import
import datetime


## file construction strings
class CLIfilestrings(object):
    ## version is implanted in all docstrings
    version = ""
    ## Automatically generated file docstring.
    docfs = """/* Generated by InputHandler's /InputHandler/cli_gen_tool/cli_gen_tool.py version {docs_version} */
/**
* @file {docs_filename}
* @author Douglas Quigg (dstroy0 dquigg123@gmail.com)
* @brief {docs_brief}
* @version {docs_version}
* @date {docs_date}
*
* @copyright Copyright (c) {docs_year}
*/
/*
* Copyright (c) {docs_year} Douglas Quigg (dstroy0) <dquigg123@gmail.com>
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License
* version 3 as published by the Free Software Foundation.
*/
"""
    ## setup.h filestring
    setup_h_fs = """
#if !defined(__CLI_SETUP__)
    #define __CLI_SETUP__
    #include "InputHandler.h"
    #include "functions.h"
    #include "parameters.h"

{outputbuffer}
const PROGMEM IH_pname pname = "{processname}"; // process name
const PROGMEM IH_eol peol = "{processeol}"; // process end of line characters
const PROGMEM IH_input_cc pinputcc = "{processinputcontrolchar}"; // input control char sequence
const PROGMEM IH_wcc pwcc = "{processwildcardchar}"; // process wildcard char

// data delimiter sequences
const PROGMEM InputProcessDelimiterSequences pdelimseq = {{
    {numdelimseq}, // number of delimiter sequences
    {delimseqlens}, // delimiter sequence lens
    {delimseqs} // delimiter sequences
}};

// start stop data delimiter sequences
const PROGMEM InputProcessStartStopSequences pststpseq = {{
    {numstartstoppairs}, // num start stop sequence pairs
    {startstopseqlens}, // start stop sequence lens
    {startstopseqs} // start stop sequence pairs
}};

const PROGMEM InputProcessParameters input_prm[1] = {{
    &pname,
    &peol,
    &pinputcc,
    &pwcc,
    &pdelimseq,
    &pststpseq}};

// constructor
{constructor}{setupprototype}{loopprototype}
// end of file
"""
    ## setup.cpp setup function
    setup_cpp_setup_function_string = """
void InputHandler_setup()
{{{setupfunctionentry}{defaultfunction}{commandlist}{begin}{options}
}}
"""
    ## setup.cpp loop function
    setup_cpp_loop_function_string = """
void InputHandler_loop()
{{{loopstatements}
}}
"""
    ## setup.cpp filestring
    setup_cpp_fs = """
#include setup.h

{setupfunction}{loopfunction}

#endif

// end of file
"""
    ## functions.h filestring
    functions_h_fs = """
#if !defined(__FUNCTIONS_H__)
    #define __FUNCTIONS_H__
    #include "InputHandler.h"
    
{functionprototypes}

#endif
// end of file
"""
    ## functions.cpp function format string
    functions_cpp_function_string = """void {functionname}(UserInput* _{objectname})
{{{statements}
}}

"""
    ## functions.cpp filestring
    functions_cpp_fs = """
#include "functions.h"
    
{functions}
// end of file
"""
    ## single CommandParameters format string
    commandparameters_string = """
/**
   @brief CommandParameters struct for {functionname}
*/
const PROGMEM CommandParameters {functionname}_param[1] = 
{{
    {functionname}, // function pointer
    {wildcardflag}, // wildcard flag
    {commandstring}, // command string
    {lencommandstring}, // command string num characters
    {parentid}, // parent id
    {commandid}, // this command id (tree unique)
    {commanddepth}, // command depth
    {commandsubcommands}, // number of subcommands
    {argumenthandling}, // argument handling
    {minnumargs}, // minimum expected number of arguments
    {maxnumargs}, // maximum expected number of arguments
    /* UITYPE arguments */
    {argtypearray}    
}};
{commandconstructor}
"""
    ## nested CommandParameters format string
    nested_commandparameters_string = """
/**
   @brief CommandParameters struct for {functionname}
*/
const PROGMEM CommandParameters {functionname}_param[1 /* root */ + {numberofchildren} /* child(ren) */] = 
{{
    {{
      {functionname}, // function pointer
      {wildcardflag}, // wildcard flag
      {commandstring}, // command string
      {lencommandstring}, // command string num characters
      {parentid}, // parent id
      {commandid}, // this command id (tree unique)
      {commanddepth}, // command depth
      {commandsubcommands}, // number of subcommands
      {argumenthandling}, // argument handling
      {minnumargs}, // minimum expected number of arguments
      {maxnumargs}, // maximum expected number of arguments
      /* UITYPE arguments */
      {argtypearray}   
    }},
    {children}    
}};
{commandconstructor}
"""
    ## parameters.h filestring
    parameters_h_fs = """
#if !defined(__PARAMETERS_H__)
    #define __PARAMETERS_H__
    #include "setup.h"
    
{parameters}

#endif
// end of file
"""
    ## file construction strings database
    fsdb = {
        "setup": {
            "h": {
                "filestring components": {
                    "outputbuffer": "\nchar {outputbuffername}[{buffersize}] = {bufferchar}; // output buffer size\n",
                    "classoutput": "({input_prm}, {outputbuffer}, buffsz({outputbuffer}))",
                    "constructor": "UserInput {objectname}{classoutput};\n",
                    "prototypes": {
                        "setup": "\nvoid InputHandler_setup();",
                        "loop": "\nvoid InputHandler_loop();",
                    },
                },
                "filestring": setup_h_fs,
            },  # end setup h
            "cpp": {
                "filestring components": {
                    "setup function": setup_cpp_setup_function_string,
                    "loop function": setup_cpp_loop_function_string,
                    "addCommand": {
                        "call": "\n  {objectname}.addCommand({commandparametersname});"
                    },
                    "defaultFunction": {
                        "call": "\n  {objectname}.defaultFunction({defaultfunctionname}); // default function is called when user input has no match or is not valid"
                    },
                    "listCommands": {
                        "call": "\n  {objectname}.listCommands(); // formats {outputbuffer} with the command list"
                    },
                    "listSettings": {
                        "call": "\n  {objectname}.listSettings(); // formats {outputbuffer} with the process settings (uses a lot of ram; for setting and testing)"
                    },
                    "outputToStream": {
                        "call": "\n  {objectname}.outputToStream({stream}); // class output"
                    },
                    "begin": {
                        "call": "\n  {objectname}.begin(); // Required. Returns true on success."
                    },
                    "setup function output": {
                        "stream": '\n  {stream}.println(F("{setupstring}"));',
                        "buffer": '\n  if ((buffsz({outputbuffer})-outputIsAvailable()) > strlen("{setupstring}")+1) {{\n    snprintf_P({outputbuffer} + outputIsAvailable(), "{setupstring}");\n  }}',
                    },
                },
                "filestring": setup_cpp_fs,
            },  # end setup cpp
        },  # end setup
        "functions": {
            "h": {
                "filestring components": {
                    "function prototype": "\nvoid {functionname}(UserInput* _{objectname});"
                },
                "filestring": functions_h_fs,
            },  # end functions h
            "cpp": {
                "filestring components": {
                    "outputToStream": {
                        "call": "\n  _{objectname}->outputToStream({stream});"
                    },
                    "listCommands": {"call": "\n  _{objectname}->listCommands();"},
                    "listSettings": {
                        "call": "\n  _{objectname}->listSettings({objectname});"
                    },
                    "function": functions_cpp_function_string,
                },
                "filestring": functions_cpp_fs,
            },  # end functions cpp
        },  # end functions
        "parameters": {
            "h": {
                "filestring components": {
                    "nested child": "    *{functionname}_param{comma} // pointer to {functionname}_param\n",
                    "command constructor": "CommandConstructor {functionname}_({functionname}_param); // {functionname}_ command constructor",
                    "parameters": commandparameters_string,
                    "nested parameters": nested_commandparameters_string,
                },
                "filestring": parameters_h_fs,
            }  # end parameters h
        },  # end parameters
    }

    ## the constructor
    def __init__(self) -> None:
        super(CLIfilestrings, self).__init__()
        CLIfilestrings.version = self.version

    ## formats a docstring and returns a list populated with lines of text
    def generate_docstring_list_for_filename(self, filename, brief):
        docstring_list = []
        year = str(datetime.date.today())[0:4]
        date = datetime.date.today()
        docstring = CLIfilestrings.docfs.format(
            docs_version=CLIfilestrings.version,
            docs_filename=filename,
            docs_brief=brief,
            docs_year=year,
            docs_date=date,
        )
        docstring_list = docstring.split("\n")
        return docstring_list

    ## turns a list of text lines into a complete file string where each line ends with newline
    def list_to_code_string(self, list):
        code_string = ""
        for line in list:
            code_string = code_string + line + "\n"
        return code_string


# end of file
