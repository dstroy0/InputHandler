<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="prev" title="Source" href="../src.html" />

    <meta name="generator" content="sphinx-5.2.0.post0, furo 2022.09.15"/>
        <title>InputHandler - InputHandler documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=9ec31e2665bf879c1d47d93a8ec4893870ee1e45" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">InputHandler  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">InputHandler  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Command Line Interface Generation tool reference (InputHandler.h)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#inputhandler">InputHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#supported-platforms">Supported Platforms</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference external" href=".. _docs: https://dstroy0.github.io/InputHandler/cli_gen_tool/index.html">.. _docs: https://dstroy0.github.io/InputHandler/cli_gen_tool/index.html</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../src.html">Source</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">InputHandler</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="inputhandler">
<h1>InputHandler<a class="headerlink" href="#inputhandler" title="Permalink to this heading">#</a></h1>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv49UI_CMD_ID">
<span id="_CPPv39UI_CMD_ID"></span><span id="_CPPv29UI_CMD_ID"></span><span class="target" id="de/d8a/group___user_input_1ga166e5457949a4e09a4391b2bacbb1db0"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UI_CMD_ID</span></span></span><a class="headerlink" href="#_CPPv49UI_CMD_ID" title="Permalink to this definition">#</a><br /></dt>
<dd><p>command identifier enum this is used to explicitly state something is related to a root command in the context of UserInput::CommandParameters </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N9UI_CMD_ID4rootE">
<span id="_CPPv3N9UI_CMD_ID4rootE"></span><span id="_CPPv2N9UI_CMD_ID4rootE"></span><span class="target" id="de/d8a/group___user_input_1gga166e5457949a4e09a4391b2bacbb1db0ae87665181d83c0613d7d3fdceaa293de"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">root</span></span></span><a class="headerlink" href="#_CPPv4N9UI_CMD_ID4rootE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>this is the root command id, it’s the number 0 ALWAYS </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv410UI_WC_FLAG">
<span id="_CPPv310UI_WC_FLAG"></span><span id="_CPPv210UI_WC_FLAG"></span><span class="target" id="de/d8a/group___user_input_1gae655f6a50054ff5649f7ab9509d64f14"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UI_WC_FLAG</span></span></span><a class="headerlink" href="#_CPPv410UI_WC_FLAG" title="Permalink to this definition">#</a><br /></dt>
<dd><p>command wildcard flag enum these flags are used inside of UserInput::CommandParameters </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10UI_WC_FLAG12no_wildcardsE">
<span id="_CPPv3N10UI_WC_FLAG12no_wildcardsE"></span><span id="_CPPv2N10UI_WC_FLAG12no_wildcardsE"></span><span class="target" id="de/d8a/group___user_input_1ggae655f6a50054ff5649f7ab9509d64f14a0681c51d081bef2c026443ddb77c8127"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">no_wildcards</span></span></span><a class="headerlink" href="#_CPPv4N10UI_WC_FLAG12no_wildcardsE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>this command has no wildcard char (false (0)) </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10UI_WC_FLAG13has_wildcardsE">
<span id="_CPPv3N10UI_WC_FLAG13has_wildcardsE"></span><span id="_CPPv2N10UI_WC_FLAG13has_wildcardsE"></span><span class="target" id="de/d8a/group___user_input_1ggae655f6a50054ff5649f7ab9509d64f14aecae04b6672265aa9a4e0ec44826d67e"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">has_wildcards</span></span></span><a class="headerlink" href="#_CPPv4N10UI_WC_FLAG13has_wildcardsE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>this command contains one or more wildcard char (true (1)) </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv410UI_COMPARE">
<span id="_CPPv310UI_COMPARE"></span><span id="_CPPv210UI_COMPARE"></span><span class="target" id="de/d8a/group___user_input_1ga6d345262e77318723edf20f58dc745b6"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UI_COMPARE</span></span></span><a class="headerlink" href="#_CPPv410UI_COMPARE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>UserInput::_compareCommandToString() return values these flags are only used to provide clarity to UserInput::_compareCommandToString(), they make it easy to understand what is happening inside of that method. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10UI_COMPARE8no_matchE">
<span id="_CPPv3N10UI_COMPARE8no_matchE"></span><span id="_CPPv2N10UI_COMPARE8no_matchE"></span><span class="target" id="de/d8a/group___user_input_1gga6d345262e77318723edf20f58dc745b6aeee61f4d0c0fc1ad344a6a588f235aaf"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">no_match</span></span></span><a class="headerlink" href="#_CPPv4N10UI_COMPARE8no_matchE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>no match </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10UI_COMPARE17match_all_wcc_cmdE">
<span id="_CPPv3N10UI_COMPARE17match_all_wcc_cmdE"></span><span id="_CPPv2N10UI_COMPARE17match_all_wcc_cmdE"></span><span class="target" id="de/d8a/group___user_input_1gga6d345262e77318723edf20f58dc745b6ab79e93058f227b5f637272d3d6b40cdb"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">match_all_wcc_cmd</span></span></span><a class="headerlink" href="#_CPPv4N10UI_COMPARE17match_all_wcc_cmdE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>match all wcc command </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10UI_COMPARE5matchE">
<span id="_CPPv3N10UI_COMPARE5matchE"></span><span id="_CPPv2N10UI_COMPARE5matchE"></span><span class="target" id="de/d8a/group___user_input_1gga6d345262e77318723edf20f58dc745b6aff192c21885a659cb1069ef9498a3069"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">match</span></span></span><a class="headerlink" href="#_CPPv4N10UI_COMPARE5matchE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>match command </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum-class">
<dt class="sig sig-object cpp" id="_CPPv415UI_ARG_HANDLING">
<span id="_CPPv315UI_ARG_HANDLING"></span><span id="_CPPv215UI_ARG_HANDLING"></span><span class="target" id="de/d8a/group___user_input_1gaaf7aee82204b26b1dc80fcefa29ea8b9"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UI_ARG_HANDLING</span></span></span><a class="headerlink" href="#_CPPv415UI_ARG_HANDLING" title="Permalink to this definition">#</a><br /></dt>
<dd><p>strongly typed argument handling flags this is used in UserInput::CommandParameters as a visual reminder of how the process will handle your arguments </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15UI_ARG_HANDLING7no_argsE">
<span id="_CPPv3N15UI_ARG_HANDLING7no_argsE"></span><span id="_CPPv2N15UI_ARG_HANDLING7no_argsE"></span><span class="target" id="de/d8a/group___user_input_1ggaaf7aee82204b26b1dc80fcefa29ea8b9a517c5dac9a168ab48e4727ca5ada9741"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">no_args</span></span></span><a class="headerlink" href="#_CPPv4N15UI_ARG_HANDLING7no_argsE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>no arguments expected </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15UI_ARG_HANDLING8one_typeE">
<span id="_CPPv3N15UI_ARG_HANDLING8one_typeE"></span><span id="_CPPv2N15UI_ARG_HANDLING8one_typeE"></span><span class="target" id="de/d8a/group___user_input_1ggaaf7aee82204b26b1dc80fcefa29ea8b9afd1b59a959f982928e0b4e79bb42dd67"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">one_type</span></span></span><a class="headerlink" href="#_CPPv4N15UI_ARG_HANDLING8one_typeE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>every argument is of the same type </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15UI_ARG_HANDLING8type_arrE">
<span id="_CPPv3N15UI_ARG_HANDLING8type_arrE"></span><span id="_CPPv2N15UI_ARG_HANDLING8type_arrE"></span><span class="target" id="de/d8a/group___user_input_1ggaaf7aee82204b26b1dc80fcefa29ea8b9aad69e504bf949689b02f44ff8246d98f"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">type_arr</span></span></span><a class="headerlink" href="#_CPPv4N15UI_ARG_HANDLING8type_arrE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>there is an array of input types </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum-class">
<dt class="sig sig-object cpp" id="_CPPv46UITYPE">
<span id="_CPPv36UITYPE"></span><span id="_CPPv26UITYPE"></span><span class="target" id="de/d8a/group___user_input_1ga70e7c464dbd2c5c26fa63684d9dfdd70"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UITYPE</span></span></span><a class="headerlink" href="#_CPPv46UITYPE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#dc/d4b/class_user_input"><span class="std std-ref">UserInput</span></a> type specifier these are the different types of user input the process can accept NOTYPE and START_STOP can be any 0-255 value This is strongly typed to help avoid name conflicts, and as an indicator that these types are not built-in. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE7UINT8_TE">
<span id="_CPPv3N6UITYPE7UINT8_TE"></span><span id="_CPPv2N6UITYPE7UINT8_TE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70a25185a78b19f8b194e2955929e32baca"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UINT8_T</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE7UINT8_TE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>8-bit unsigned integer </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE8UINT16_TE">
<span id="_CPPv3N6UITYPE8UINT16_TE"></span><span id="_CPPv2N6UITYPE8UINT16_TE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70abd93e66a884d0291f3db5bb0eeb03ffe"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UINT16_T</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE8UINT16_TE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>16-bit unsigned integer </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE8UINT32_TE">
<span id="_CPPv3N6UITYPE8UINT32_TE"></span><span id="_CPPv2N6UITYPE8UINT32_TE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70abc0d406b455d82bfc780c67be1976fed"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UINT32_T</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE8UINT32_TE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>32-bit unsigned integer </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE7INT16_TE">
<span id="_CPPv3N6UITYPE7INT16_TE"></span><span id="_CPPv2N6UITYPE7INT16_TE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70a5e66c6e44fda6975bc1d1f10f4ea0436"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">INT16_T</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE7INT16_TE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>16-bit signed integer </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE5FLOATE">
<span id="_CPPv3N6UITYPE5FLOATE"></span><span id="_CPPv2N6UITYPE5FLOATE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70ae738c26bf4ce1037fa81b039a915cbf6"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FLOAT</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE5FLOATE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>32-bit float </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE4CHARE">
<span id="_CPPv3N6UITYPE4CHARE"></span><span id="_CPPv2N6UITYPE4CHARE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70a027acd3aa6b1dd7f26119d3cf0f9a063"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CHAR</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE4CHARE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>8-bit char </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE10START_STOPE">
<span id="_CPPv3N6UITYPE10START_STOPE"></span><span id="_CPPv2N6UITYPE10START_STOPE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70af749dae7024a2aceb2b15cb807300aef"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">START_STOP</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE10START_STOPE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>array of 8-bit char </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE6NOTYPEE">
<span id="_CPPv3N6UITYPE6NOTYPEE"></span><span id="_CPPv2N6UITYPE6NOTYPEE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70a0323d2829f046f18b7dbcc0f58f941bc"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NOTYPE</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE6NOTYPEE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>no type validation </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE7NO_ARGSE">
<span id="_CPPv3N6UITYPE7NO_ARGSE"></span><span id="_CPPv2N6UITYPE7NO_ARGSE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70acd158bf723602ecc6429b5771682a716"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NO_ARGS</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE7NO_ARGSE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>no arguments expected </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE5_LASTE">
<span id="_CPPv3N6UITYPE5_LASTE"></span><span id="_CPPv2N6UITYPE5_LASTE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70aaa55687588914f1c2a506982d7f57948"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_LAST</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE5_LASTE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>reserved </p>
</dd></dl>

</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv430InputProcessDelimiterSequences">
<span id="_CPPv330InputProcessDelimiterSequences"></span><span id="_CPPv230InputProcessDelimiterSequences"></span><span id="InputProcessDelimiterSequences"></span><span class="target" id="dc/da2/struct_input_process_delimiter_sequences"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InputProcessDelimiterSequences</span></span></span><a class="headerlink" href="#_CPPv430InputProcessDelimiterSequences" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#dc/da2/struct_input_process_delimiter_sequences"><span class="std std-ref">InputProcessDelimiterSequences</span></a> struct holds user defined input data delimiters This struct holds information about the delimiter sequences the process will be using. A delimiter sequence is a predefined number or set of numbers that is used to separate input arguments, subcommands or data. The input process needs to know three things about the delimiter sequences you want to use. The number of delimiter sequences there are (up to UI_MAX_DELIM_SEQ), the 8-bit byte (char) length of each delimiter sequence, and finally each delimiter sequence which can be up to UI_DELIM_SEQ_PGM_LEN in length. </p>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv430InputProcessStartStopSequences">
<span id="_CPPv330InputProcessStartStopSequences"></span><span id="_CPPv230InputProcessStartStopSequences"></span><span id="InputProcessStartStopSequences"></span><span class="target" id="d4/dc0/struct_input_process_start_stop_sequences"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InputProcessStartStopSequences</span></span></span><a class="headerlink" href="#_CPPv430InputProcessStartStopSequences" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#d4/dc0/struct_input_process_start_stop_sequences"><span class="std std-ref">InputProcessStartStopSequences</span></a> struct holds regex-like start-stop match sequence pairs This struct holds information about the start-stop sequence pairs the process will be using. A start-stop sequence is a pair of numbers or a pair of a set of numbers which do not have to be identical to one another. The “start” sequence demarcs the beginning of a chunk of data, the “stop” sequence demarcs the end of the chunk of data. The input process needs to know three things about the start-stop sequences you want to use. The number of start-stop sequences there are (up to UI_MAX_START_STOP_SEQ), the 8-bit byte (char) length of each start-stop sequence, and finally each start-stop sequence which can be up to UI_START_STOP_SEQ_PGM_LEN in length. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv48IH_pname">
<span id="_CPPv38IH_pname"></span><span id="_CPPv28IH_pname"></span><span id="IH_pname"></span><span class="target" id="de/d8a/group___user_input_1ga561fa7484e19f7dfebcf361ecd585f2f"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IH_pname</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">UI_PROCESS_NAME_PGM_LEN</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv48IH_pname" title="Permalink to this definition">#</a><br /></dt>
<dd><p>IH_pname is a char array typedef the size of UI_PROCESS_NAME_PGM_LEN This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv46IH_eol">
<span id="_CPPv36IH_eol"></span><span id="_CPPv26IH_eol"></span><span id="IH_eol"></span><span class="target" id="de/d8a/group___user_input_1gafbde6b816485ab1d1e6e22b3b0cb9f02"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IH_eol</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">UI_EOL_SEQ_PGM_LEN</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv46IH_eol" title="Permalink to this definition">#</a><br /></dt>
<dd><p>IH_eol is a char array typedef the size of UI_EOL_SEQ_PGM_LEN This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv411IH_input_cc">
<span id="_CPPv311IH_input_cc"></span><span id="_CPPv211IH_input_cc"></span><span id="IH_input_cc"></span><span class="target" id="de/d8a/group___user_input_1ga85f676c44db484981373328e3dbf0698"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IH_input_cc</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">UI_INPUT_CONTROL_CHAR_SEQ_PGM_LEN</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv411IH_input_cc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>IH_input_cc is a char array typedef the size of UI_INPUT_CONTROL_CHAR_SEQ_PGM_LEN This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv46IH_wcc">
<span id="_CPPv36IH_wcc"></span><span id="_CPPv26IH_wcc"></span><span id="IH_wcc"></span><span class="target" id="de/d8a/group___user_input_1gae5ba9d1632e0bccd924cf01102d0af3d"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IH_wcc</span></span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv46IH_wcc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>IH_wcc is a two char array that represents the wildcard char and a null terminator This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h. </p>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv422InputProcessParameters">
<span id="_CPPv322InputProcessParameters"></span><span id="_CPPv222InputProcessParameters"></span><span id="InputProcessParameters"></span><span class="target" id="db/dda/struct_input_process_parameters"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InputProcessParameters</span></span></span><a class="headerlink" href="#_CPPv422InputProcessParameters" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#dc/d4b/class_user_input"><span class="std std-ref">UserInput</span></a> input process parameters, constructor parameters This struct is an array of pointers to other structs/arrays contained in PROGMEM It’s required by the input process, all together they define the input process behavior. </p>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv418CommandRuntimeCalc">
<span id="_CPPv318CommandRuntimeCalc"></span><span id="_CPPv218CommandRuntimeCalc"></span><span id="CommandRuntimeCalc"></span><span class="target" id="dc/d3d/struct_command_runtime_calc"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CommandRuntimeCalc</span></span></span><a class="headerlink" href="#_CPPv418CommandRuntimeCalc" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#dc/d3d/struct_command_runtime_calc"><span class="std std-ref">CommandRuntimeCalc</span></a> struct contains arrays and indices determined at runtime these structs are associated with wildcard commands; every <a class="reference internal" href="#df/d68/class_command_constructor"><span class="std std-ref">CommandConstructor</span></a> that has a <a class="reference internal" href="#db/d11/struct_command_parameters"><span class="std std-ref">CommandParameters</span></a> which contains wildcards will have a <a class="reference internal" href="#dc/d3d/struct_command_runtime_calc"><span class="std std-ref">CommandRuntimeCalc</span></a>. </p>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv417CommandParameters">
<span id="_CPPv317CommandParameters"></span><span id="_CPPv217CommandParameters"></span><span id="CommandParameters"></span><span class="target" id="db/d11/struct_command_parameters"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CommandParameters</span></span></span><a class="headerlink" href="#_CPPv417CommandParameters" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#db/d11/struct_command_parameters"><span class="std std-ref">CommandParameters</span></a> struct, this is the container that holds your command parameters. </p>
<p>Every command and subcommand has an associated <a class="reference internal" href="#db/d11/struct_command_parameters"><span class="std std-ref">CommandParameters</span></a> object, this is the information that the input process needs to know about your command </p>
</dd></dl>

<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv418CommandConstructor">
<span id="_CPPv318CommandConstructor"></span><span id="_CPPv218CommandConstructor"></span><span id="CommandConstructor"></span><span class="target" id="df/d68/class_command_constructor"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CommandConstructor</span></span></span><a class="headerlink" href="#_CPPv418CommandConstructor" title="Permalink to this definition">#</a><br /></dt>
<dd><p>user command constructor class </p>
</dd></dl>

<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv49UserInput">
<span id="_CPPv39UserInput"></span><span id="_CPPv29UserInput"></span><span id="UserInput"></span><span class="target" id="dc/d4b/class_user_input"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UserInput</span></span></span><a class="headerlink" href="#_CPPv49UserInput" title="Permalink to this definition">#</a><br /></dt>
<dd><p>User input handler methods. </p>
</dd></dl>

<section id="inputhandler-h">
<h2>InputHandler.h<a class="headerlink" href="#inputhandler-h" title="Permalink to this heading">#</a></h2>
<div class="literal-block-wrapper docutils container" id="id1">
<div class="code-block-caption"><span class="caption-text">src/InputHandler.h</span><a class="headerlink" href="#id1" title="Permalink to this code">#</a></div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="linenos">  1</span><span class="cm">/**</span>
<span class="linenos">  2</span><span class="cm"> * @file InputHandler.h</span>
<span class="linenos">  3</span><span class="cm"> * @author Douglas Quigg (dstroy0 dquigg123@gmail.com)</span>
<span class="linenos">  4</span><span class="cm"> * @brief InputHandler library header file</span>
<span class="linenos">  5</span><span class="cm"> * @version 1.1</span>
<span class="linenos">  6</span><span class="cm"> * @date 2022-05-28</span>
<span class="linenos">  7</span><span class="cm"> *</span>
<span class="linenos">  8</span><span class="cm"> * @copyright Copyright (c) 2022</span>
<span class="linenos">  9</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 10</span><span class="cm">/*</span>
<span class="linenos"> 11</span><span class="cm"> Copyright (C) 2022 Douglas Quigg (dstroy0) &lt;dquigg123@gmail.com&gt;</span>
<span class="linenos"> 12</span>
<span class="linenos"> 13</span><span class="cm"> This program is free software; you can redistribute it and/or</span>
<span class="linenos"> 14</span><span class="cm"> modify it under the terms of the GNU General Public License</span>
<span class="linenos"> 15</span><span class="cm"> version 3 as published by the Free Software Foundation.</span>
<span class="linenos"> 16</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 17</span><span class="cp">#if !defined(__USER_INPUT_HANDLER_H__)</span>
<span class="linenos"> 18</span><span class="w">    </span><span class="cp">#define __USER_INPUT_HANDLER_H__</span>
<span class="linenos"> 19</span>
<span class="linenos"> 20</span><span class="w">    </span><span class="c1">// user configurable items located in src/config/config.h and src/config/advanced_config.h</span>
<span class="linenos"> 21</span><span class="w">    </span><span class="c1">// see examples/all_platforms/advanced/GetCommandFromStream.ino for an example</span>
<span class="linenos"> 22</span><span class="w">    </span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;config/noedit.h&quot;</span><span class="cp"></span>
<span class="linenos"> 23</span>
<span class="linenos"> 24</span><span class="cm">/**</span>
<span class="linenos"> 25</span><span class="cm"> * @defgroup UserInput class constants</span>
<span class="linenos"> 26</span><span class="cm"> * @{</span>
<span class="linenos"> 27</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 28</span>
<span class="linenos"> 29</span><span class="cm">/**</span>
<span class="linenos"> 30</span><span class="cm"> * @brief command identifier enum</span>
<span class="linenos"> 31</span><span class="cm"> * this is used to explicitly state something is related to a root command</span>
<span class="linenos"> 32</span><span class="cm"> * in the context of UserInput::CommandParameters</span>
<span class="linenos"> 33</span><span class="cm"> * @enum UI_CMD_ID</span>
<span class="linenos"> 34</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 35</span><span class="k">enum</span><span class="w"> </span><span class="nc">UI_CMD_ID</span><span class="w"></span>
<span class="linenos"> 36</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 37</span><span class="w">    </span><span class="n">root</span><span class="w"> </span><span class="c1">///&lt; this is the root command id, it&#39;s the number 0 ALWAYS</span>
<span class="linenos"> 38</span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 39</span>
<span class="linenos"> 40</span><span class="cm">/**</span>
<span class="linenos"> 41</span><span class="cm"> * @brief command wildcard flag enum</span>
<span class="linenos"> 42</span><span class="cm"> * these flags are used inside of UserInput::CommandParameters</span>
<span class="linenos"> 43</span><span class="cm"> * @enum UI_WC_FLAG</span>
<span class="linenos"> 44</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 45</span><span class="k">enum</span><span class="w"> </span><span class="nc">UI_WC_FLAG</span><span class="w"></span>
<span class="linenos"> 46</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 47</span><span class="w">    </span><span class="n">no_wildcards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="c1">///&lt; this command has no wildcard char (false (0))</span>
<span class="linenos"> 48</span><span class="w">    </span><span class="n">has_wildcards</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="w">  </span><span class="c1">///&lt; this command contains one or more wildcard char (true (1))</span>
<span class="linenos"> 49</span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 50</span>
<span class="linenos"> 51</span><span class="cm">/**</span>
<span class="linenos"> 52</span><span class="cm"> * @brief UserInput::_compareCommandToString() return values</span>
<span class="linenos"> 53</span><span class="cm"> * these flags are only used to provide clarity to UserInput::_compareCommandToString(),</span>
<span class="linenos"> 54</span><span class="cm"> * they make it easy to understand what is happening inside of that method</span>
<span class="linenos"> 55</span><span class="cm"> * @enum UI_COMPARE</span>
<span class="linenos"> 56</span><span class="cm"> *</span>
<span class="linenos"> 57</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 58</span><span class="k">enum</span><span class="w"> </span><span class="nc">UI_COMPARE</span><span class="w"></span>
<span class="linenos"> 59</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 60</span><span class="w">    </span><span class="n">no_match</span><span class="p">,</span><span class="w">          </span><span class="c1">///&lt; no match</span>
<span class="linenos"> 61</span><span class="w">    </span><span class="n">match_all_wcc_cmd</span><span class="p">,</span><span class="w"> </span><span class="c1">///&lt; match all wcc command</span>
<span class="linenos"> 62</span><span class="w">    </span><span class="n">match</span><span class="w">              </span><span class="c1">///&lt; match command</span>
<span class="linenos"> 63</span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 64</span>
<span class="linenos"> 65</span><span class="cm">/**</span>
<span class="linenos"> 66</span><span class="cm"> * @brief strongly typed argument handling flags</span>
<span class="linenos"> 67</span><span class="cm"> * this is used in UserInput::CommandParameters as a visual reminder of</span>
<span class="linenos"> 68</span><span class="cm"> * how the process will handle your arguments</span>
<span class="linenos"> 69</span><span class="cm"> * @enum UI_ARG_HANDLING</span>
<span class="linenos"> 70</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 71</span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">UI_ARG_HANDLING</span><span class="w"></span>
<span class="linenos"> 72</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 73</span><span class="w">    </span><span class="n">no_args</span><span class="p">,</span><span class="w">  </span><span class="c1">///&lt;  no arguments expected</span>
<span class="linenos"> 74</span><span class="w">    </span><span class="n">one_type</span><span class="p">,</span><span class="w"> </span><span class="c1">///&lt;  every argument is of the same type</span>
<span class="linenos"> 75</span><span class="w">    </span><span class="n">type_arr</span><span class="w">  </span><span class="c1">///&lt;  there is an array of input types</span>
<span class="linenos"> 76</span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 77</span>
<span class="linenos"> 78</span><span class="cm">/**</span>
<span class="linenos"> 79</span><span class="cm"> * @brief UserInput type specifier</span>
<span class="linenos"> 80</span><span class="cm"> * these are the different types of user input the process can accept</span>
<span class="linenos"> 81</span><span class="cm"> * NOTYPE and START_STOP can be any 0-255 value</span>
<span class="linenos"> 82</span><span class="cm"> * This is strongly typed to help avoid name conflicts, and as an indicator that</span>
<span class="linenos"> 83</span><span class="cm"> * these types are not built-in.</span>
<span class="linenos"> 84</span><span class="cm"> * @enum UITYPE</span>
<span class="linenos"> 85</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos"> 86</span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">UITYPE</span><span class="w"></span>
<span class="linenos"> 87</span><span class="p">{</span><span class="w"></span>
<span class="linenos"> 88</span><span class="w">    </span><span class="n">UINT8_T</span><span class="p">,</span><span class="w">    </span><span class="c1">///&lt;  8-bit unsigned integer</span>
<span class="linenos"> 89</span><span class="w">    </span><span class="n">UINT16_T</span><span class="p">,</span><span class="w">   </span><span class="c1">///&lt;  16-bit unsigned integer</span>
<span class="linenos"> 90</span><span class="w">    </span><span class="n">UINT32_T</span><span class="p">,</span><span class="w">   </span><span class="c1">///&lt;  32-bit unsigned integer</span>
<span class="linenos"> 91</span><span class="w">    </span><span class="n">INT16_T</span><span class="p">,</span><span class="w">    </span><span class="c1">///&lt;  16-bit signed integer</span>
<span class="linenos"> 92</span><span class="w">    </span><span class="n">FLOAT</span><span class="p">,</span><span class="w">      </span><span class="c1">///&lt;  32-bit float</span>
<span class="linenos"> 93</span><span class="w">    </span><span class="n">CHAR</span><span class="p">,</span><span class="w">       </span><span class="c1">///&lt;  8-bit char</span>
<span class="linenos"> 94</span><span class="w">    </span><span class="n">START_STOP</span><span class="p">,</span><span class="w"> </span><span class="c1">///&lt;  array of 8-bit char</span>
<span class="linenos"> 95</span><span class="w">    </span><span class="n">NOTYPE</span><span class="p">,</span><span class="w">     </span><span class="c1">///&lt;  no type validation</span>
<span class="linenos"> 96</span><span class="w">    </span><span class="n">NO_ARGS</span><span class="p">,</span><span class="w">    </span><span class="c1">///&lt;  no arguments expected</span>
<span class="linenos"> 97</span><span class="w">    </span><span class="n">_LAST</span><span class="w">       </span><span class="c1">///&lt;  reserved</span>
<span class="linenos"> 98</span><span class="p">};</span><span class="w"></span>
<span class="linenos"> 99</span>
<span class="linenos">100</span><span class="cm">/**</span>
<span class="linenos">101</span><span class="cm"> * @brief type string literals</span>
<span class="linenos">102</span><span class="cm"> * input type string literal PROGMEM array, each of the types in UITYPE has</span>
<span class="linenos">103</span><span class="cm"> * a corresponding string literal for display purposes</span>
<span class="linenos">104</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">105</span><span class="k">const</span><span class="w"> </span><span class="n">PROGMEM</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">UserInput_type_strings_pgm</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="n">UI_INPUT_TYPE_STRINGS_PGM_LEN</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">106</span><span class="w">    </span><span class="s">&quot;UINT8_T&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1">// 8-bit unsigned integer</span>
<span class="linenos">107</span><span class="w">    </span><span class="s">&quot;UINT16_T&quot;</span><span class="p">,</span><span class="w">  </span><span class="c1">// 16-bit unsigned integer</span>
<span class="linenos">108</span><span class="w">    </span><span class="s">&quot;UINT32_T&quot;</span><span class="p">,</span><span class="w">  </span><span class="c1">// 32-bit unsigned integer</span>
<span class="linenos">109</span><span class="w">    </span><span class="s">&quot;INT16_T&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1">// 16-bit signed integer</span>
<span class="linenos">110</span><span class="w">    </span><span class="s">&quot;FLOAT&quot;</span><span class="p">,</span><span class="w">     </span><span class="c1">// 32-bit floating point number</span>
<span class="linenos">111</span><span class="w">    </span><span class="s">&quot;CHAR&quot;</span><span class="p">,</span><span class="w">      </span><span class="c1">// single char</span>
<span class="linenos">112</span><span class="w">    </span><span class="s">&quot;STARTSTOP&quot;</span><span class="p">,</span><span class="w"> </span><span class="c1">// c-string enclosed with start/stop delimiters</span>
<span class="linenos">113</span><span class="w">    </span><span class="s">&quot;NOTYPE&quot;</span><span class="p">,</span><span class="w">    </span><span class="c1">// user defined NOTYPE</span>
<span class="linenos">114</span><span class="w">    </span><span class="s">&quot;NO_ARGS&quot;</span><span class="p">,</span><span class="w">   </span><span class="c1">// no arguments expected</span>
<span class="linenos">115</span><span class="w">    </span><span class="s">&quot;error&quot;</span><span class="w">      </span><span class="c1">// error</span>
<span class="linenos">116</span><span class="p">};</span><span class="w"></span>
<span class="linenos">117</span>
<span class="linenos">118</span><span class="cm">/**</span>
<span class="linenos">119</span><span class="cm"> * @brief InputProcessDelimiterSequences struct holds user defined input data delimiters</span>
<span class="linenos">120</span><span class="cm"> * This struct holds information about the delimiter sequences the process will be using.</span>
<span class="linenos">121</span><span class="cm"> * A delimiter sequence is a predefined number or set of numbers that is used to separate</span>
<span class="linenos">122</span><span class="cm"> * input arguments, subcommands or data.  The input process needs to know three things</span>
<span class="linenos">123</span><span class="cm"> * about the delimiter sequences you want to use.  The number of delimiter sequences there are</span>
<span class="linenos">124</span><span class="cm"> * (up to UI_MAX_DELIM_SEQ), the 8-bit byte (char) length of each delimiter sequence, and</span>
<span class="linenos">125</span><span class="cm"> * finally each delimiter sequence which can be up to UI_DELIM_SEQ_PGM_LEN in length.</span>
<span class="linenos">126</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">127</span><span class="k">struct</span><span class="w"> </span><span class="nc">InputProcessDelimiterSequences</span><span class="w"></span>
<span class="linenos">128</span><span class="p">{</span><span class="w"></span>
<span class="linenos">129</span><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_seq</span><span class="p">;</span><span class="w">                                                       </span><span class="c1">///&lt; the number of token delimiters in delimiter_sequences</span>
<span class="linenos">130</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_num_delim_seq_t</span><span class="w"> </span><span class="n">delimiter_lens</span><span class="p">[</span><span class="n">UI_MAX_NUM_DELIM_SEQ</span><span class="p">];</span><span class="w">      </span><span class="c1">///&lt; delimiter sequence lens</span>
<span class="linenos">131</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">delimiter_sequences</span><span class="p">[</span><span class="n">UI_MAX_NUM_DELIM_SEQ</span><span class="p">][</span><span class="n">UI_DELIM_SEQ_PGM_LEN</span><span class="p">];</span><span class="w"> </span><span class="c1">///&lt; string-literal &quot;&quot; delimiter sequence array</span>
<span class="linenos">132</span><span class="p">};</span><span class="w"></span>
<span class="linenos">133</span>
<span class="linenos">134</span><span class="cm">/**</span>
<span class="linenos">135</span><span class="cm"> * @brief InputProcessStartStopSequences struct holds regex-like start-stop match sequence pairs</span>
<span class="linenos">136</span><span class="cm"> * This struct holds information about the start-stop sequence pairs the process will be using.</span>
<span class="linenos">137</span><span class="cm"> * A start-stop sequence is a pair of numbers or a pair of a set of numbers which do not have to</span>
<span class="linenos">138</span><span class="cm"> * be identical to one another.  The &quot;start&quot; sequence demarcs the beginning of a chunk of data,</span>
<span class="linenos">139</span><span class="cm"> * the &quot;stop&quot; sequence demarcs the end of the chunk of data. The input process needs to know</span>
<span class="linenos">140</span><span class="cm"> * three things about the start-stop sequences you want to use.  The number of start-stop</span>
<span class="linenos">141</span><span class="cm"> * sequences there are (up to UI_MAX_START_STOP_SEQ), the 8-bit byte (char) length of each</span>
<span class="linenos">142</span><span class="cm"> * start-stop sequence, and finally each start-stop sequence which can be up to</span>
<span class="linenos">143</span><span class="cm"> * UI_START_STOP_SEQ_PGM_LEN in length.</span>
<span class="linenos">144</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">145</span><span class="k">struct</span><span class="w"> </span><span class="nc">InputProcessStartStopSequences</span><span class="w"></span>
<span class="linenos">146</span><span class="p">{</span><span class="w"></span>
<span class="linenos">147</span><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_seq</span><span class="p">;</span><span class="w">                                                                       </span><span class="c1">///&lt; num start/stop sequences</span>
<span class="linenos">148</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_num_start_stop_seq_t</span><span class="w"> </span><span class="n">start_stop_sequence_lens</span><span class="p">[</span><span class="n">UI_MAX_NUM_START_STOP_SEQ</span><span class="p">];</span><span class="w">  </span><span class="c1">///&lt; start stop sequence lens</span>
<span class="linenos">149</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">start_stop_sequence_pairs</span><span class="p">[</span><span class="n">UI_MAX_NUM_START_STOP_SEQ</span><span class="p">][</span><span class="n">UI_START_STOP_SEQ_PGM_LEN</span><span class="p">];</span><span class="w"> </span><span class="c1">///&lt; start/stop sequences.  Match start, match end, copy what is between</span>
<span class="linenos">150</span><span class="p">};</span><span class="w"></span>
<span class="linenos">151</span>
<span class="linenos">152</span><span class="cm">/**</span>
<span class="linenos">153</span><span class="cm"> * @brief IH_pname is a char array typedef the size of UI_PROCESS_NAME_PGM_LEN</span>
<span class="linenos">154</span><span class="cm"> * This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h</span>
<span class="linenos">155</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">156</span><span class="k">typedef</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">IH_pname</span><span class="p">[</span><span class="n">UI_PROCESS_NAME_PGM_LEN</span><span class="p">];</span><span class="w"></span>
<span class="linenos">157</span>
<span class="linenos">158</span><span class="cm">/**</span>
<span class="linenos">159</span><span class="cm"> * @brief IH_eol is a char array typedef the size of UI_EOL_SEQ_PGM_LEN</span>
<span class="linenos">160</span><span class="cm"> * This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h</span>
<span class="linenos">161</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">162</span><span class="k">typedef</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">IH_eol</span><span class="p">[</span><span class="n">UI_EOL_SEQ_PGM_LEN</span><span class="p">];</span><span class="w"></span>
<span class="linenos">163</span>
<span class="linenos">164</span><span class="cm">/**</span>
<span class="linenos">165</span><span class="cm"> * @brief IH_input_cc is a char array typedef the size of UI_INPUT_CONTROL_CHAR_SEQ_PGM_LEN</span>
<span class="linenos">166</span><span class="cm"> * This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h</span>
<span class="linenos">167</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">168</span><span class="k">typedef</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">IH_input_cc</span><span class="p">[</span><span class="n">UI_INPUT_CONTROL_CHAR_SEQ_PGM_LEN</span><span class="p">];</span><span class="w"></span>
<span class="linenos">169</span>
<span class="linenos">170</span><span class="cm">/**</span>
<span class="linenos">171</span><span class="cm"> * @brief IH_wcc is a two char array that represents the wildcard char and a null terminator</span>
<span class="linenos">172</span><span class="cm"> * This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h</span>
<span class="linenos">173</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">174</span><span class="k">typedef</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">IH_wcc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span><span class="w"></span>
<span class="linenos">175</span>
<span class="linenos">176</span><span class="cm">/**</span>
<span class="linenos">177</span><span class="cm"> * @brief UserInput input process parameters, constructor parameters</span>
<span class="linenos">178</span><span class="cm"> * This struct is an array of pointers to other structs/arrays contained in PROGMEM</span>
<span class="linenos">179</span><span class="cm"> * It&#39;s required by the input process, all together they define the input process behavior</span>
<span class="linenos">180</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">181</span><span class="k">struct</span><span class="w"> </span><span class="nc">InputProcessParameters</span><span class="w"></span>
<span class="linenos">182</span><span class="p">{</span><span class="w"></span>
<span class="linenos">183</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">IH_pname</span><span class="o">*</span><span class="w"> </span><span class="n">pname</span><span class="p">;</span><span class="w">                           </span><span class="c1">///&lt; this process&#39; name, can be NULL; MAX len == UI_PROCESS_NAME_PGM_LEN</span>
<span class="linenos">184</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">IH_eol</span><span class="o">*</span><span class="w"> </span><span class="n">peol</span><span class="p">;</span><span class="w">                              </span><span class="c1">///&lt; end of line term; MAX len == UI_EOL_SEQ_PGM_LEN</span>
<span class="linenos">185</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">IH_input_cc</span><span class="o">*</span><span class="w"> </span><span class="n">pinputcc</span><span class="p">;</span><span class="w">                     </span><span class="c1">///&lt; two char len sequence to input a control char</span>
<span class="linenos">186</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">IH_wcc</span><span class="o">*</span><span class="w"> </span><span class="n">pwcc</span><span class="p">;</span><span class="w">                              </span><span class="c1">///&lt; single char wildcard char</span>
<span class="linenos">187</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">InputProcessDelimiterSequences</span><span class="o">*</span><span class="w"> </span><span class="n">pdelimseq</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; reference to InputProcessDelimiterSequences struct</span>
<span class="linenos">188</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">InputProcessStartStopSequences</span><span class="o">*</span><span class="w"> </span><span class="n">pststpseq</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; reference to InputProcessStartStopSequences struct</span>
<span class="linenos">189</span><span class="p">};</span><span class="w"></span>
<span class="linenos">190</span>
<span class="linenos">191</span><span class="k">const</span><span class="w"> </span><span class="n">PROGMEM</span><span class="w"> </span><span class="n">IH_pname</span><span class="w"> </span><span class="n">_pname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span><span class="w">         </span><span class="c1">///&lt; default process name == &quot;&quot;</span>
<span class="linenos">192</span><span class="k">const</span><span class="w"> </span><span class="n">PROGMEM</span><span class="w"> </span><span class="n">IH_eol</span><span class="w"> </span><span class="n">_peol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w">        </span><span class="c1">///&lt; default process eol characters &quot;\\r\\n&quot;</span>
<span class="linenos">193</span><span class="k">const</span><span class="w"> </span><span class="n">PROGMEM</span><span class="w"> </span><span class="n">IH_input_cc</span><span class="w"> </span><span class="n">_pinputcc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;##&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; default process input control character sequence &quot;##&quot;</span>
<span class="linenos">194</span><span class="k">const</span><span class="w"> </span><span class="n">PROGMEM</span><span class="w"> </span><span class="n">IH_wcc</span><span class="w"> </span><span class="n">_pwcc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;*&quot;</span><span class="p">;</span><span class="w">           </span><span class="c1">///&lt; default process wildcard char &#39;*&#39;</span>
<span class="linenos">195</span>
<span class="linenos">196</span><span class="cm">/**</span>
<span class="linenos">197</span><span class="cm"> * @brief default delimiter sequences</span>
<span class="linenos">198</span><span class="cm"> *</span>
<span class="linenos">199</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">200</span><span class="k">const</span><span class="w"> </span><span class="n">PROGMEM</span><span class="w"> </span><span class="n">InputProcessDelimiterSequences</span><span class="w"> </span><span class="n">_pdelimseq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">201</span><span class="w">    </span><span class="mi">2</span><span class="p">,</span><span class="w">         </span><span class="c1">///&lt; default number of delimiter sequences</span>
<span class="linenos">202</span><span class="w">    </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w">    </span><span class="c1">///&lt; default delimiter sequence lens</span>
<span class="linenos">203</span><span class="w">    </span><span class="p">{</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;,&quot;</span><span class="p">}</span><span class="w"> </span><span class="c1">///&lt; default delimiter sequences</span>
<span class="linenos">204</span><span class="p">};</span><span class="w"></span>
<span class="linenos">205</span>
<span class="linenos">206</span><span class="cm">/**</span>
<span class="linenos">207</span><span class="cm"> * @brief default start stop sequences</span>
<span class="linenos">208</span><span class="cm"> *</span>
<span class="linenos">209</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">210</span><span class="k">const</span><span class="w"> </span><span class="n">PROGMEM</span><span class="w"> </span><span class="n">InputProcessStartStopSequences</span><span class="w"> </span><span class="n">_pststpseq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">211</span><span class="w">    </span><span class="mi">1</span><span class="p">,</span><span class="w">           </span><span class="c1">///&lt; default num start stop sequence pairs</span>
<span class="linenos">212</span><span class="w">    </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">},</span><span class="w">      </span><span class="c1">///&lt; default start stop sequence lens</span>
<span class="linenos">213</span><span class="w">    </span><span class="p">{</span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">}</span><span class="w"> </span><span class="c1">///&lt; default start stop sequence pair sequences</span>
<span class="linenos">214</span><span class="p">};</span><span class="w"></span>
<span class="linenos">215</span>
<span class="linenos">216</span><span class="cm">/**</span>
<span class="linenos">217</span><span class="cm"> * @brief UserInput default InputProcessParameters</span>
<span class="linenos">218</span><span class="cm"> *</span>
<span class="linenos">219</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">220</span><span class="k">const</span><span class="w"> </span><span class="n">PROGMEM</span><span class="w"> </span><span class="n">InputProcessParameters</span><span class="w"> </span><span class="n">_DEFAULT_UI_INPUT_PRM_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="linenos">221</span><span class="w">    </span><span class="o">&amp;</span><span class="n">_pname</span><span class="p">,</span><span class="w">     </span><span class="c1">///&lt; default process name</span>
<span class="linenos">222</span><span class="w">    </span><span class="o">&amp;</span><span class="n">_peol</span><span class="p">,</span><span class="w">      </span><span class="c1">///&lt; default process eol term</span>
<span class="linenos">223</span><span class="w">    </span><span class="o">&amp;</span><span class="n">_pinputcc</span><span class="p">,</span><span class="w">  </span><span class="c1">///&lt; default process input control char sequence</span>
<span class="linenos">224</span><span class="w">    </span><span class="o">&amp;</span><span class="n">_pwcc</span><span class="p">,</span><span class="w">      </span><span class="c1">///&lt; default process wildcard char</span>
<span class="linenos">225</span><span class="w">    </span><span class="o">&amp;</span><span class="n">_pdelimseq</span><span class="p">,</span><span class="w"> </span><span class="c1">///&lt; default process default delimiter sequences</span>
<span class="linenos">226</span><span class="w">    </span><span class="o">&amp;</span><span class="n">_pststpseq</span><span class="w">  </span><span class="c1">///&lt; default process default start/stop sequences</span>
<span class="linenos">227</span><span class="p">};</span><span class="w"></span>
<span class="linenos">228</span>
<span class="linenos">229</span><span class="cm">/**</span>
<span class="linenos">230</span><span class="cm"> * @brief CommandRuntimeCalc struct contains arrays and indices determined at runtime</span>
<span class="linenos">231</span><span class="cm"> * these structs are associated with wildcard commands; every CommandConstructor</span>
<span class="linenos">232</span><span class="cm"> * that has a CommandParameters which contains wildcards will have a CommandRuntimeCalc</span>
<span class="linenos">233</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">234</span><span class="k">struct</span><span class="w"> </span><span class="nc">CommandRuntimeCalc</span><span class="w"></span>
<span class="linenos">235</span><span class="p">{</span><span class="w"></span>
<span class="linenos">236</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">memcmp_idx_t</span><span class="w"> </span><span class="n">num_prm_with_wc</span><span class="p">;</span><span class="w">                    </span><span class="c1">///&lt; the number of CommandParameters structs in this command that contain char(IH_wcc[0]); the WildCard Character</span>
<span class="linenos">237</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">memcmp_idx_t</span><span class="o">*</span><span class="w"> </span><span class="n">idx_of_prm_with_wc</span><span class="p">;</span><span class="w">                </span><span class="c1">///&lt; indices of CommandParameters struct that contain wcc</span>
<span class="linenos">238</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_per_cmd_memcmp_ranges_t</span><span class="o">*</span><span class="w"> </span><span class="n">num_memcmp_ranges_this_row</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; the number of memcmp ranges for this Parameters command string, array members always an even number</span>
<span class="linenos">239</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_per_cmd_memcmp_ranges_t</span><span class="o">**</span><span class="w"> </span><span class="n">memcmp_ranges_arr</span><span class="p">;</span><span class="w">         </span><span class="c1">///&lt; 2d array[row][col], each [row] is for one Parameters command string which contains wcc</span>
<span class="linenos">240</span><span class="p">};</span><span class="w"></span>
<span class="linenos">241</span>
<span class="linenos">242</span><span class="cm">/**</span>
<span class="linenos">243</span><span class="cm"> * @brief forward declaration of UserInput class for</span>
<span class="linenos">244</span><span class="cm"> * CommandParameters struct and CommandConstructor class</span>
<span class="linenos">245</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">246</span><span class="k">class</span><span class="w"> </span><span class="nc">UserInput</span><span class="p">;</span><span class="w"></span>
<span class="linenos">247</span>
<span class="linenos">248</span><span class="cm">/**</span>
<span class="linenos">249</span><span class="cm"> * @brief CommandParameters struct, this is the container that holds your command parameters</span>
<span class="linenos">250</span><span class="cm"> *</span>
<span class="linenos">251</span><span class="cm"> * Every command and subcommand has an associated CommandParameters object, this is the information</span>
<span class="linenos">252</span><span class="cm"> * that the input process needs to know about your command</span>
<span class="linenos">253</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">254</span><span class="k">struct</span><span class="w"> </span><span class="nc">CommandParameters</span><span class="w"></span>
<span class="linenos">255</span><span class="p">{</span><span class="w"></span>
<span class="linenos">256</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="n">UserInput</span><span class="o">*</span><span class="p">);</span><span class="w">                 </span><span class="c1">///&lt; void function pointer, void your_function(UserInput *inputProcess)</span>
<span class="linenos">257</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">has_wildcards</span><span class="p">;</span><span class="w">                           </span><span class="c1">///&lt; if true this command has one or more wildcard char</span>
<span class="linenos">258</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">command</span><span class="p">[</span><span class="n">UI_MAX_CMD_LEN</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1U</span><span class="p">];</span><span class="w">            </span><span class="c1">///&lt; command string + &#39;\0&#39;</span>
<span class="linenos">259</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_cmd_len_t</span><span class="w"> </span><span class="n">command_length</span><span class="p">;</span><span class="w">          </span><span class="c1">///&lt; command length in characters</span>
<span class="linenos">260</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">cmd_id_grp_t</span><span class="w"> </span><span class="n">parent_command_id</span><span class="p">;</span><span class="w">           </span><span class="c1">///&lt; parent command&#39;s unique id root-MAX</span>
<span class="linenos">261</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">cmd_id_grp_t</span><span class="w"> </span><span class="n">command_id</span><span class="p">;</span><span class="w">                  </span><span class="c1">///&lt; this command&#39;s unique id root-MAX</span>
<span class="linenos">262</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_tree_depth_per_command_t</span><span class="w"> </span><span class="n">depth</span><span class="p">;</span><span class="w">    </span><span class="c1">///&lt; command tree depth root-MAX</span>
<span class="linenos">263</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_num_child_commands_t</span><span class="w"> </span><span class="n">sub_commands</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; how many subcommands does this command have 0 - UI_MAX_SUBCOMMANDS</span>
<span class="linenos">264</span><span class="w">    </span><span class="n">UI_ARG_HANDLING</span><span class="w"> </span><span class="n">argument_flag</span><span class="p">;</span><span class="w">                </span><span class="c1">///&lt; argument handling flag</span>
<span class="linenos">265</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_args_t</span><span class="w"> </span><span class="n">num_args</span><span class="p">;</span><span class="w">                   </span><span class="c1">///&lt; minimum number of arguments this command expects 0 - UI_MAX_ARGS</span>
<span class="linenos">266</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_args_t</span><span class="w"> </span><span class="n">max_num_args</span><span class="p">;</span><span class="w">               </span><span class="c1">///&lt; maximum number of arguments this command expects 0 - UI_MAX_ARGS, cannot be less than num_args</span>
<span class="linenos">267</span><span class="w">    </span><span class="n">UITYPE</span><span class="w"> </span><span class="n">arg_type_arr</span><span class="p">[</span><span class="n">UI_MAX_ARGS_PER_COMMAND</span><span class="p">];</span><span class="w"> </span><span class="c1">///&lt; argument UITYPE array</span>
<span class="linenos">268</span><span class="p">};</span><span class="w"></span>
<span class="linenos">269</span><span class="cm">/** @} */</span><span class="w"></span>
<span class="linenos">270</span>
<span class="linenos">271</span><span class="cm">/**</span>
<span class="linenos">272</span><span class="cm"> * @brief user command constructor class</span>
<span class="linenos">273</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">274</span><span class="k">class</span><span class="w"> </span><span class="nc">CommandConstructor</span><span class="w"></span>
<span class="linenos">275</span><span class="p">{</span><span class="w"></span>
<span class="linenos">276</span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="linenos">277</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">278</span><span class="cm">     * @brief CommandConstructor Constructor</span>
<span class="linenos">279</span><span class="cm">     *</span>
<span class="linenos">280</span><span class="cm">     * Linked-list primer: https://www.programiz.com/dsa/linked-list</span>
<span class="linenos">281</span><span class="cm">     *</span>
<span class="linenos">282</span><span class="cm">     * These constructors are chained together as a linked-list; this CommandConstructor</span>
<span class="linenos">283</span><span class="cm">     * object contains a reference CommandConstructor::next_command to the next node</span>
<span class="linenos">284</span><span class="cm">     * in the linked-list.  The list is linked together in UserInput::addCommand().</span>
<span class="linenos">285</span><span class="cm">     *</span>
<span class="linenos">286</span><span class="cm">     * Before using, construct a UserInput object and a CommandParameters object.</span>
<span class="linenos">287</span><span class="cm">     * @param parameters pointer to parameters struct or array of parameters structs</span>
<span class="linenos">288</span><span class="cm">     * @param parameter_array_elements number of elements in the parameter array</span>
<span class="linenos">289</span><span class="cm">     * @param tree_depth depth of command tree</span>
<span class="linenos">290</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">291</span><span class="w">    </span><span class="n">CommandConstructor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">CommandParameters</span><span class="o">*</span><span class="w"> </span><span class="n">parameters</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_commands_in_tree_t</span><span class="w"> </span><span class="n">parameter_array_elements</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_tree_depth_per_command_t</span><span class="w"> </span><span class="n">tree_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="linenos">292</span><span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">prm</span><span class="p">(</span><span class="n">parameters</span><span class="p">),</span><span class="w"></span>
<span class="linenos">293</span><span class="w">          </span><span class="n">param_array_len</span><span class="p">(</span><span class="n">parameter_array_elements</span><span class="p">),</span><span class="w"></span>
<span class="linenos">294</span><span class="w">          </span><span class="n">tree_depth</span><span class="p">(</span><span class="n">tree_depth</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1U</span><span class="p">),</span><span class="w"></span>
<span class="linenos">295</span><span class="w">          </span><span class="n">calc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span><span class="w"></span>
<span class="linenos">296</span><span class="w">          </span><span class="n">next_command</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span><span class="w"></span>
<span class="linenos">297</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos">298</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">299</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">CommandParameters</span><span class="o">*</span><span class="w"> </span><span class="n">prm</span><span class="p">;</span><span class="w">                        </span><span class="c1">///&lt; pointer to PROGMEM CommandParameters array</span>
<span class="linenos">300</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_commands_in_tree_t</span><span class="w"> </span><span class="n">param_array_len</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; user input param array len, either as digits or through nprms</span>
<span class="linenos">301</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_commands_in_tree_t</span><span class="w"> </span><span class="n">tree_depth</span><span class="p">;</span><span class="w">      </span><span class="c1">///&lt; user input depth + 1</span>
<span class="linenos">302</span><span class="w">    </span><span class="n">CommandRuntimeCalc</span><span class="o">*</span><span class="w"> </span><span class="n">calc</span><span class="p">;</span><span class="w">                            </span><span class="c1">///&lt; pointer to CommandRuntimeCalc struct</span>
<span class="linenos">303</span><span class="w">    </span><span class="n">CommandConstructor</span><span class="o">*</span><span class="w"> </span><span class="n">next_command</span><span class="p">;</span><span class="w">                    </span><span class="c1">///&lt; CommandConstructor iterator/pointer</span>
<span class="linenos">304</span><span class="p">};</span><span class="w"></span>
<span class="linenos">305</span>
<span class="linenos">306</span><span class="cm">/**</span>
<span class="linenos">307</span><span class="cm"> * @brief User input handler methods</span>
<span class="linenos">308</span><span class="cm"> */</span><span class="w"></span>
<span class="linenos">309</span><span class="k">class</span><span class="w"> </span><span class="nc">UserInput</span><span class="w"></span>
<span class="linenos">310</span><span class="p">{</span><span class="w"></span>
<span class="linenos">311</span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="linenos">312</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">313</span><span class="cm">     * @name UserInput class</span>
<span class="linenos">314</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">315</span>
<span class="linenos">316</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">317</span><span class="cm">     * @brief UserInput constructor, no output by default</span>
<span class="linenos">318</span><span class="cm">     *</span>
<span class="linenos">319</span><span class="cm">     * UserInput has no output by default due to the default values passed in by the constructor.</span>
<span class="linenos">320</span><span class="cm">     * The constructor disables output by setting `_output_enabled_` to false if output_buffer is</span>
<span class="linenos">321</span><span class="cm">     * NULL.</span>
<span class="linenos">322</span><span class="cm">     *</span>
<span class="linenos">323</span><span class="cm">     * @param input_prm InputProcessParameters struct pointer.  NULL by default, which causes the ctor to use _DEFAULT_UI_INPUT_PRM_ unless you define your own</span>
<span class="linenos">324</span><span class="cm">     * @param output_buffer class output char buffer, implementation specific.  NULL by default.</span>
<span class="linenos">325</span><span class="cm">     * @param output_buffer_len size of output_buffer buffsz(output_buffer)     </span>
<span class="linenos">326</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">327</span><span class="w">    </span><span class="n">UserInput</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">InputProcessParameters</span><span class="o">*</span><span class="w"> </span><span class="n">input_prm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">output_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">output_buffer_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="linenos">328</span><span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">_input_prm_ptr_</span><span class="p">((</span><span class="n">input_prm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="o">&amp;</span><span class="n">_DEFAULT_UI_INPUT_PRM_</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">input_prm</span><span class="p">),</span><span class="w"></span>
<span class="linenos">329</span><span class="w">          </span><span class="n">_output_buffer_</span><span class="p">(</span><span class="n">output_buffer</span><span class="p">),</span><span class="w"></span>
<span class="linenos">330</span><span class="w">          </span><span class="n">_output_buffer_len_</span><span class="p">(</span><span class="n">output_buffer_len</span><span class="p">),</span><span class="w">          </span>
<span class="linenos">331</span><span class="w">          </span><span class="n">_output_enabled_</span><span class="p">((</span><span class="n">output_buffer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">true</span><span class="p">),</span><span class="w"></span>
<span class="linenos">332</span><span class="w">          </span><span class="n">_output_buffer_bytes_left_</span><span class="p">(</span><span class="n">output_buffer_len</span><span class="p">),</span><span class="w"></span>
<span class="linenos">333</span><span class="w">          </span><span class="n">_term_len_</span><span class="p">(</span><span class="n">strlen_P</span><span class="p">(((</span><span class="n">input_prm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">_DEFAULT_UI_INPUT_PRM_</span><span class="p">.</span><span class="n">peol</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">input_prm</span><span class="o">-&gt;</span><span class="n">peol</span><span class="p">))),</span><span class="w"></span>
<span class="linenos">334</span><span class="w">          </span><span class="n">_term_index_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">335</span><span class="w">          </span><span class="n">_default_function_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span><span class="w"></span>
<span class="linenos">336</span><span class="w">          </span><span class="n">_commands_head_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span><span class="w"></span>
<span class="linenos">337</span><span class="w">          </span><span class="n">_commands_tail_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span><span class="w"></span>
<span class="linenos">338</span><span class="w">          </span><span class="n">_commands_count_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">339</span><span class="w">          </span><span class="n">_max_depth_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">340</span><span class="w">          </span><span class="n">_max_args_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">341</span><span class="w">          </span><span class="n">_input_type_match_flags_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span><span class="w"></span>
<span class="linenos">342</span><span class="w">          </span><span class="n">_output_flag_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="w"></span>
<span class="linenos">343</span><span class="w">          </span><span class="n">_token_buffer_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span><span class="w"></span>
<span class="linenos">344</span><span class="w">          </span><span class="n">_data_pointers_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span><span class="w"></span>
<span class="linenos">345</span><span class="w">          </span><span class="n">_data_pointers_index_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">346</span><span class="w">          </span><span class="n">_data_pointers_index_max_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">347</span><span class="w">          </span><span class="n">_p_num_ptrs_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">348</span><span class="w">          </span><span class="n">_rec_num_arg_strings_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">349</span><span class="w">          </span><span class="n">_failed_on_subcommand_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">350</span><span class="w">          </span><span class="n">_current_search_depth_</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"></span>
<span class="linenos">351</span><span class="w">          </span><span class="n">_null_</span><span class="p">(</span><span class="sc">&#39;\0&#39;</span><span class="p">),</span><span class="w"></span>
<span class="linenos">352</span><span class="w">          </span><span class="n">_neg_</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">),</span><span class="w"></span>
<span class="linenos">353</span><span class="w">          </span><span class="n">_dot_</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">),</span><span class="w"></span>
<span class="linenos">354</span><span class="w">          </span><span class="n">_stream_buffer_allocated_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="w"></span>
<span class="linenos">355</span><span class="w">          </span><span class="n">_new_stream_data_</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span><span class="w"></span>
<span class="linenos">356</span><span class="w">          </span><span class="n">_stream_data_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">),</span><span class="w"></span>
<span class="linenos">357</span><span class="w">          </span><span class="n">_stream_data_index_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="linenos">358</span><span class="w">          </span><span class="n">_begin_</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span><span class="w"></span>
<span class="linenos">359</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos">360</span><span class="w">        </span><span class="n">memcpy_P</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_input_prm_</span><span class="p">,</span><span class="w"> </span><span class="n">_input_prm_ptr_</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">_input_prm_</span><span class="p">));</span><span class="w"></span>
<span class="linenos">361</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">362</span>
<span class="linenos">363</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">364</span><span class="cm">     * @brief Sets the _default_function_ pointer</span>
<span class="linenos">365</span><span class="cm">     * When there is no command match, or when input is invalid, this function is called</span>
<span class="linenos">366</span><span class="cm">     * if the pointer is not NULL</span>
<span class="linenos">367</span><span class="cm">     *</span>
<span class="linenos">368</span><span class="cm">     * @param function a pointer to a user specified default function</span>
<span class="linenos">369</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">370</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">defaultFunction</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="n">UserInput</span><span class="o">*</span><span class="p">));</span><span class="w"></span>
<span class="linenos">371</span>
<span class="linenos">372</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">373</span><span class="cm">     * @brief adds user commands to the input process</span>
<span class="linenos">374</span><span class="cm">     *</span>
<span class="linenos">375</span><span class="cm">     * This function inspects CommandParameters for errors and</span>
<span class="linenos">376</span><span class="cm">     * reports the errors to the user if they have enabled output.</span>
<span class="linenos">377</span><span class="cm">     * If an error is detected in the root command or any of</span>
<span class="linenos">378</span><span class="cm">     * its subcommands, the entire command tree is rejected,</span>
<span class="linenos">379</span><span class="cm">     * and sizing for dynamically allocated variables does not</span>
<span class="linenos">380</span><span class="cm">     * take place.</span>
<span class="linenos">381</span><span class="cm">     *</span>
<span class="linenos">382</span><span class="cm">     * @param command reference to CommandConstructor object</span>
<span class="linenos">383</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">384</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">addCommand</span><span class="p">(</span><span class="n">CommandConstructor</span><span class="o">&amp;</span><span class="w"> </span><span class="n">command</span><span class="p">);</span><span class="w"></span>
<span class="linenos">385</span>
<span class="linenos">386</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">387</span><span class="cm">     * @brief Allocates memory for _data_pointers_ and _input_type_match_flags_, sets _begin_</span>
<span class="linenos">388</span><span class="cm">     *</span>
<span class="linenos">389</span><span class="cm">     * @return true if allocation successful</span>
<span class="linenos">390</span><span class="cm">     * @return false if allocation unsuccessful</span>
<span class="linenos">391</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">392</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">begin</span><span class="p">();</span><span class="w"></span>
<span class="linenos">393</span>
<span class="linenos">394</span><span class="w">    </span><span class="cp">#if defined(ENABLE_listSettings)</span>
<span class="linenos">395</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">396</span><span class="cm">     * @brief Lists UserInput class settings, useful for implementation debugging. REQUIRES 570 byte output_buffer.</span>
<span class="linenos">397</span><span class="cm">     *</span>
<span class="linenos">398</span><span class="cm">     * Lists all pertinient process information:</span>
<span class="linenos">399</span><span class="cm">     * class configuration, constructor variables,</span>
<span class="linenos">400</span><span class="cm">     * and the amount of pointers that were dynamically</span>
<span class="linenos">401</span><span class="cm">     * allocated in UserInput::begin()</span>
<span class="linenos">402</span><span class="cm">     *</span>
<span class="linenos">403</span><span class="cm">     * REQUIRES a 650 byte output_buffer.  If an insufficient buffer size is declared,</span>
<span class="linenos">404</span><span class="cm">     * UserInput::_ui_out() will warn the user to increase the buffer to the required size.</span>
<span class="linenos">405</span><span class="cm">     *</span>
<span class="linenos">406</span><span class="cm">     * @param inputProcess pointer to class instance</span>
<span class="linenos">407</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">408</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">listSettings</span><span class="p">(</span><span class="n">UserInput</span><span class="o">*</span><span class="w"> </span><span class="n">inputProcess</span><span class="p">);</span><span class="w"></span>
<span class="linenos">409</span><span class="w">    </span><span class="cp">#endif</span>
<span class="linenos">410</span>
<span class="linenos">411</span><span class="w">    </span><span class="cp">#if defined(ENABLE_listCommands)</span>
<span class="linenos">412</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">413</span><span class="cm">     * @brief Lists commands that will respond to user input if `_begin_` == true</span>
<span class="linenos">414</span><span class="cm">     * else it will inform the user to use begin() in setup()</span>
<span class="linenos">415</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">416</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">listCommands</span><span class="p">();</span><span class="w"></span>
<span class="linenos">417</span><span class="w">    </span><span class="cp">#endif</span>
<span class="linenos">418</span>
<span class="linenos">419</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">420</span><span class="cm">     * @brief Used internally by UserInput::readCommandFromBuffer() and passed by reference</span>
<span class="linenos">421</span><span class="cm">     *</span>
<span class="linenos">422</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">423</span><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">_rcfbprm</span><span class="w"></span>
<span class="linenos">424</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos">425</span><span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">launch_attempted</span><span class="p">;</span><span class="w">           </span><span class="c1">///&lt; function launch attempted if true</span>
<span class="linenos">426</span><span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">command_matched</span><span class="p">;</span><span class="w">            </span><span class="c1">///&lt; matched root command if true</span>
<span class="linenos">427</span><span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">all_arguments_valid</span><span class="p">;</span><span class="w">        </span><span class="c1">///&lt; argument error sentinel</span>
<span class="linenos">428</span><span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">subcommand_matched</span><span class="p">;</span><span class="w">         </span><span class="c1">///&lt; matched a subcommand</span>
<span class="linenos">429</span><span class="w">        </span><span class="n">CommandConstructor</span><span class="o">*</span><span class="w"> </span><span class="n">cmd</span><span class="p">;</span><span class="w">         </span><span class="c1">///&lt; pointer to CommandConstructor</span>
<span class="linenos">430</span><span class="w">        </span><span class="n">CommandConstructor</span><span class="o">*</span><span class="w"> </span><span class="n">all_wcc_cmd</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; pointer to CommandConstructor</span>
<span class="linenos">431</span><span class="w">        </span><span class="n">UI_COMPARE</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">               </span><span class="c1">///&lt; result of UserInput::_compareCommandToString()</span>
<span class="linenos">432</span><span class="w">        </span><span class="n">IH</span><span class="o">::</span><span class="n">cmd_id_grp_t</span><span class="w"> </span><span class="n">command_id</span><span class="p">;</span><span class="w">     </span><span class="c1">///&lt; type set by macro</span>
<span class="linenos">433</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span><span class="w">                      </span><span class="c1">///&lt; CommandParameters index</span>
<span class="linenos">434</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">all_wcc_idx</span><span class="p">;</span><span class="w">              </span><span class="c1">///&lt; index of CommandParameters that has an all wcc command</span>
<span class="linenos">435</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">input_len</span><span class="p">;</span><span class="w">                </span><span class="c1">///&lt; length of input data</span>
<span class="linenos">436</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">token_buffer_len</span><span class="p">;</span><span class="w">         </span><span class="c1">///&lt; length of token buffer</span>
<span class="linenos">437</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">tokens_received</span><span class="p">;</span><span class="w">          </span><span class="c1">///&lt; how many tokens we received</span>
<span class="linenos">438</span><span class="w">        </span><span class="n">CommandParameters</span><span class="w"> </span><span class="n">prm</span><span class="p">;</span><span class="w">           </span><span class="c1">///&lt; CommandParameters struct</span>
<span class="linenos">439</span><span class="w">        </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">input_data</span><span class="p">;</span><span class="w">             </span><span class="c1">///&lt; pointer to input_data</span>
<span class="linenos">440</span><span class="w">        </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">split_input</span><span class="p">;</span><span class="w">            </span><span class="c1">///&lt; pointer to UserInput::_splitZDC() modified data</span>
<span class="linenos">441</span><span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="linenos">442</span>
<span class="linenos">443</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">444</span><span class="cm">     * @brief read command(s) from a uint8_t (unsigned char) buffer</span>
<span class="linenos">445</span><span class="cm">     * silent return if UserInput::_begin_ == false</span>
<span class="linenos">446</span><span class="cm">     * @param data a buffer with characters</span>
<span class="linenos">447</span><span class="cm">     * @param len the size of the buffer</span>
<span class="linenos">448</span><span class="cm">     * @param num_zdc size of CommandParameters zero delimiter command pointers array</span>
<span class="linenos">449</span><span class="cm">     * @param zdc array of CommandParameters zero delimiter command pointers</span>
<span class="linenos">450</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">451</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">readCommandFromBuffer</span><span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_zdc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CommandParameters</span><span class="o">**</span><span class="w"> </span><span class="n">zdc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="linenos">452</span>
<span class="linenos">453</span><span class="w">    </span><span class="cp">#if defined(ENABLE_getCommandFromStream)</span>
<span class="linenos">454</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">455</span><span class="cm">     * @brief Gets bytes from a Stream object and feeds a buffer to readCommandFromBuffer</span>
<span class="linenos">456</span><span class="cm">     *</span>
<span class="linenos">457</span><span class="cm">     * https://www.arduino.cc/reference/en/language/functions/communication/stream/</span>
<span class="linenos">458</span><span class="cm">     *</span>
<span class="linenos">459</span><span class="cm">     * silent return if UserInput::_begin_ == false</span>
<span class="linenos">460</span><span class="cm">     * @param stream the stream to reference</span>
<span class="linenos">461</span><span class="cm">     * @param rx_buffer_size the size of our receive buffer</span>
<span class="linenos">462</span><span class="cm">     * @param num_zdc size of CommandParameters zero delimiter command pointers array</span>
<span class="linenos">463</span><span class="cm">     * @param zdc array of CommandParameters zero delimiter command pointers</span>
<span class="linenos">464</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">465</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">getCommandFromStream</span><span class="p">(</span><span class="n">Stream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">rx_buffer_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_zdc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CommandParameters</span><span class="o">**</span><span class="w"> </span><span class="n">zdc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="linenos">466</span><span class="w">    </span><span class="cp">#endif</span>
<span class="linenos">467</span>
<span class="linenos">468</span><span class="w">    </span><span class="cp">#if defined(ENABLE_nextArgument)</span>
<span class="linenos">469</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">470</span><span class="cm">     * @brief returns a pointer to the next token in UserInput::_token_buffer_ or NULL if there are no more tokens</span>
<span class="linenos">471</span><span class="cm">     *</span>
<span class="linenos">472</span><span class="cm">     * @return char*</span>
<span class="linenos">473</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">474</span><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">nextArgument</span><span class="p">();</span><span class="w"></span>
<span class="linenos">475</span><span class="w">    </span><span class="cp">#endif</span>
<span class="linenos">476</span>
<span class="linenos">477</span><span class="w">    </span><span class="cp">#if defined(ENABLE_getArgument)</span>
<span class="linenos">478</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">479</span><span class="cm">     * @brief returns a pointer to argument_number token in UserInput::_token_buffer_ or NULL if there is no argument_number token</span>
<span class="linenos">480</span><span class="cm">     *</span>
<span class="linenos">481</span><span class="cm">     * @return char*</span>
<span class="linenos">482</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">483</span><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">getArgument</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">argument_number</span><span class="p">);</span><span class="w"></span>
<span class="linenos">484</span><span class="w">    </span><span class="cp">#endif</span>
<span class="linenos">485</span>
<span class="linenos">486</span><span class="w">    </span><span class="cp">#if defined(ENABLE_outputIsAvailable)</span>
<span class="linenos">487</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">488</span><span class="cm">     * @brief class output available if the return of this function is greater than zero</span>
<span class="linenos">489</span><span class="cm">     * </span>
<span class="linenos">490</span><span class="cm">     * (True) if greater than 0 </span>
<span class="linenos">491</span><span class="cm">     * (False) if 0</span>
<span class="linenos">492</span><span class="cm">     *</span>
<span class="linenos">493</span><span class="cm">     * @return the number of bytes available for output, or zero if there is no output     </span>
<span class="linenos">494</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">495</span><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">outputIsAvailable</span><span class="p">();</span><span class="w"></span>
<span class="linenos">496</span><span class="w">    </span><span class="cp">#endif</span>
<span class="linenos">497</span>
<span class="linenos">498</span><span class="w">    </span><span class="cp">#if defined(ENABLE_outputIsEnabled)</span>
<span class="linenos">499</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">500</span><span class="cm">     * @brief is class output enabled</span>
<span class="linenos">501</span><span class="cm">     *</span>
<span class="linenos">502</span><span class="cm">     * @return true if enabled</span>
<span class="linenos">503</span><span class="cm">     * @return false if not enabled</span>
<span class="linenos">504</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">505</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">outputIsEnabled</span><span class="p">();</span><span class="w"></span>
<span class="linenos">506</span><span class="w">    </span><span class="cp">#endif</span>
<span class="linenos">507</span>
<span class="linenos">508</span><span class="w">    </span><span class="cp">#if defined(ENABLE_outputToStream)</span>
<span class="linenos">509</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">510</span><span class="cm">     * @brief direct class output to stream, clears output buffer automatically</span>
<span class="linenos">511</span><span class="cm">     *</span>
<span class="linenos">512</span><span class="cm">     * @param stream the stream to print to</span>
<span class="linenos">513</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">514</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">outputToStream</span><span class="p">(</span><span class="n">Stream</span><span class="o">&amp;</span><span class="w"> </span><span class="n">stream</span><span class="p">);</span><span class="w"></span>
<span class="linenos">515</span><span class="w">    </span><span class="cp">#endif</span>
<span class="linenos">516</span>
<span class="linenos">517</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">518</span><span class="cm">     * @brief clears output buffer</span>
<span class="linenos">519</span><span class="cm">     *</span>
<span class="linenos">520</span><span class="cm">     * @param overwrite_contents boolean switch, clearOutputBuffer(true) writes null to entire _output_buffer_</span>
<span class="linenos">521</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">522</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">clearOutputBuffer</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">overwrite_contents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span><span class="w"></span>
<span class="linenos">523</span>
<span class="linenos">524</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">525</span><span class="cm">     * @brief UserInput::getTokensParam UserInput::getTokens() parameters data structure</span>
<span class="linenos">526</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">527</span><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">getTokensParam</span><span class="w"></span>
<span class="linenos">528</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos">529</span><span class="w">        </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">data</span><span class="p">;</span><span class="w">                    </span><span class="c1">///&lt; pointer to uint8_t array</span>
<span class="linenos">530</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w">                       </span><span class="c1">///&lt; length of uint8_t array</span>
<span class="linenos">531</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">data_pos</span><span class="p">;</span><span class="w">                  </span><span class="c1">///&lt; index of data</span>
<span class="linenos">532</span><span class="w">        </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">token_buffer</span><span class="p">;</span><span class="w">               </span><span class="c1">///&lt; pointer to null terminated char array</span>
<span class="linenos">533</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">token_buffer_len</span><span class="p">;</span><span class="w">          </span><span class="c1">///&lt; size of data + 1 + 1(if there are zero delim commands)</span>
<span class="linenos">534</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">token_buffer_index</span><span class="p">;</span><span class="w">        </span><span class="c1">///&lt; index of token_buffer</span>
<span class="linenos">535</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_token_ptrs</span><span class="p">;</span><span class="w">            </span><span class="c1">///&lt; token_pointers[MAX]</span>
<span class="linenos">536</span><span class="w">        </span><span class="kt">uint8_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">token_pointer_index</span><span class="p">;</span><span class="w">     </span><span class="c1">///&lt; index of token_pointers</span>
<span class="linenos">537</span><span class="w">        </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">token_pointers</span><span class="p">;</span><span class="w">            </span><span class="c1">///&lt; array of token_buffer pointers</span>
<span class="linenos">538</span><span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">point_to_beginning_of_token</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; assign pointer to &amp;token_buffer[token_buffer_index] if true</span>
<span class="linenos">539</span><span class="w">        </span><span class="kt">char</span><span class="o">&amp;</span><span class="w"> </span><span class="n">token_buffer_sep</span><span class="p">;</span><span class="w">           </span><span class="c1">///&lt; token_buffer token delimiter</span>
<span class="linenos">540</span><span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="linenos">541</span>
<span class="linenos">542</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">543</span><span class="cm">     * @brief puts tokens into the token buffer pointed to in getTokensParam</span>
<span class="linenos">544</span><span class="cm">     *</span>
<span class="linenos">545</span><span class="cm">     * @param gtprm UserInput::getTokensParam struct reference</span>
<span class="linenos">546</span><span class="cm">     * @param input_prm reference to InputProcessParameters struct</span>
<span class="linenos">547</span><span class="cm">     *</span>
<span class="linenos">548</span><span class="cm">     * @return size_t number of tokens retrieved</span>
<span class="linenos">549</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">550</span><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">getTokens</span><span class="p">(</span><span class="n">getTokensParam</span><span class="o">&amp;</span><span class="w"> </span><span class="n">gtprm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">InputProcessParameters</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input_prm</span><span class="p">);</span><span class="w"></span>
<span class="linenos">551</span>
<span class="linenos">552</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">553</span><span class="cm">     * @brief validateNullSepInputParam struct</span>
<span class="linenos">554</span><span class="cm">     *</span>
<span class="linenos">555</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">556</span><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">validateNullSepInputParam</span><span class="w"></span>
<span class="linenos">557</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos">558</span><span class="w">        </span><span class="n">UITYPE</span><span class="w"> </span><span class="n">arg_type</span><span class="p">;</span><span class="w">            </span><span class="c1">///&lt; the UITYPE to test</span>
<span class="linenos">559</span><span class="w">        </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">token_pointers</span><span class="p">;</span><span class="w">      </span><span class="c1">///&lt; pointers to null separated tokens</span>
<span class="linenos">560</span><span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">token_pointer_index</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; index of token_pointers to test</span>
<span class="linenos">561</span><span class="w">        </span><span class="kt">char</span><span class="o">&amp;</span><span class="w"> </span><span class="n">neg_sign</span><span class="p">;</span><span class="w">             </span><span class="c1">///&lt; single char neg sign, if different than &#39;-&#39; parseInt and the like will not assign your input negative</span>
<span class="linenos">562</span><span class="w">        </span><span class="kt">char</span><span class="o">&amp;</span><span class="w"> </span><span class="n">float_sep</span><span class="p">;</span><span class="w">            </span><span class="c1">///&lt; whole and fraction separator</span>
<span class="linenos">563</span><span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="linenos">564</span>
<span class="linenos">565</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">566</span><span class="cm">     * @brief Tries to determine if input is valid in NULL TERMINATED char arrays</span>
<span class="linenos">567</span><span class="cm">     *</span>
<span class="linenos">568</span><span class="cm">     * @param vprm validateNullSepInputParam struct reference</span>
<span class="linenos">569</span><span class="cm">     *</span>
<span class="linenos">570</span><span class="cm">     * @return true argument-type is valid</span>
<span class="linenos">571</span><span class="cm">     * @return false argument-type is not valid</span>
<span class="linenos">572</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">573</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">validateNullSepInput</span><span class="p">(</span><span class="n">validateNullSepInputParam</span><span class="o">&amp;</span><span class="w"> </span><span class="n">vprm</span><span class="p">);</span><span class="w"></span>
<span class="linenos">574</span>
<span class="linenos">575</span><span class="k">protected</span><span class="o">:</span><span class="w"></span>
<span class="linenos">576</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">577</span><span class="cm">     * @brief transform 2d matrix indices to flat array index</span>
<span class="linenos">578</span><span class="cm">     *</span>
<span class="linenos">579</span><span class="cm">     * use this to access a dynamically allocated array like a 2d matrix,</span>
<span class="linenos">580</span><span class="cm">     * this is much more performant than looping to allocate a (n&gt;1)d array,</span>
<span class="linenos">581</span><span class="cm">     * and looping again to free allocated ram.</span>
<span class="linenos">582</span><span class="cm">     *</span>
<span class="linenos">583</span><span class="cm">     * @param m_width width of the matrix</span>
<span class="linenos">584</span><span class="cm">     * @param row row you want to access</span>
<span class="linenos">585</span><span class="cm">     * @param col column you want to access</span>
<span class="linenos">586</span><span class="cm">     * @return size_t the transformed index</span>
<span class="linenos">587</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">588</span><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">mIndex</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">m_width</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"></span>
<span class="linenos">589</span><span class="w">    </span><span class="p">{</span><span class="w"></span>
<span class="linenos">590</span><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">m_width</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">col</span><span class="p">;</span><span class="w"></span>
<span class="linenos">591</span><span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="linenos">592</span>
<span class="linenos">593</span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="linenos">594</span><span class="w">    </span><span class="cm">/*</span>
<span class="linenos">595</span><span class="cm">        UserInput Constructor variables</span>
<span class="linenos">596</span><span class="cm">    */</span><span class="w"></span>
<span class="linenos">597</span>
<span class="linenos">598</span><span class="w">    </span><span class="c1">// (potentially) user entered constructor variables</span>
<span class="linenos">599</span><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">_output_buffer_</span><span class="p">;</span><span class="w">                         </span><span class="c1">///&lt; pointer to the output char buffer</span>
<span class="linenos">600</span><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">_output_buffer_len_</span><span class="p">;</span><span class="w">                    </span><span class="c1">///&lt; _output_buffer_ size in bytes</span>
<span class="linenos">601</span><span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">InputProcessParameters</span><span class="o">*</span><span class="w"> </span><span class="n">_input_prm_ptr_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; user input constructor parameters pointer</span>
<span class="linenos">602</span><span class="w">    </span><span class="c1">// end user entered constructor variables</span>
<span class="linenos">603</span>
<span class="linenos">604</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">_output_enabled_</span><span class="p">;</span><span class="w">             </span><span class="c1">///&lt; true if _output_buffer_ is not NULL (the user has defined and passed an output buffer to UserInput&#39;s constructor)</span>
<span class="linenos">605</span><span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">_output_buffer_bytes_left_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; index of _output_buffer_, messages are appended to the output buffer and this keeps track of where to write to next without overwriting</span>
<span class="linenos">606</span>
<span class="linenos">607</span><span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">_term_len_</span><span class="p">;</span><span class="w">   </span><span class="c1">///&lt; _term_ length in characters, determined in begin()</span>
<span class="linenos">608</span><span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">_term_index_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; _term_ index, match all characters in term or reject the message</span>
<span class="linenos">609</span>
<span class="linenos">610</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">_default_function_</span><span class="p">)(</span><span class="n">UserInput</span><span class="o">*</span><span class="p">);</span><span class="w"> </span><span class="c1">///&lt; pointer to the default function</span>
<span class="linenos">611</span>
<span class="linenos">612</span><span class="w">    </span><span class="c1">// linked-list</span>
<span class="linenos">613</span><span class="w">    </span><span class="n">CommandConstructor</span><span class="o">*</span><span class="w"> </span><span class="n">_commands_head_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; pointer to object list</span>
<span class="linenos">614</span><span class="w">    </span><span class="n">CommandConstructor</span><span class="o">*</span><span class="w"> </span><span class="n">_commands_tail_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; pointer to object list</span>
<span class="linenos">615</span><span class="w">    </span><span class="c1">// end linked-list</span>
<span class="linenos">616</span>
<span class="linenos">617</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_commands_in_tree_t</span><span class="w"> </span><span class="n">_commands_count_</span><span class="p">;</span><span class="w">            </span><span class="c1">///&lt; how many commands are there</span>
<span class="linenos">618</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_tree_depth_per_command_t</span><span class="w"> </span><span class="n">_max_depth_</span><span class="p">;</span><span class="w">           </span><span class="c1">///&lt; max command depth found</span>
<span class="linenos">619</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_args_t</span><span class="w"> </span><span class="n">_max_args_</span><span class="p">;</span><span class="w">                              </span><span class="c1">///&lt; max command or subcommand arguments found</span>
<span class="linenos">620</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">input_type_match_flags_type</span><span class="o">*</span><span class="w"> </span><span class="n">_input_type_match_flags_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; bool array _input_type_match_flags_[_max_args_]</span>
<span class="linenos">621</span>
<span class="linenos">622</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">_output_flag_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; output is available flag, set by member functions</span>
<span class="linenos">623</span>
<span class="linenos">624</span><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">_token_buffer_</span><span class="p">;</span><span class="w">                        </span><span class="c1">///&lt; pointer to tokenized c-string</span>
<span class="linenos">625</span><span class="w">    </span><span class="kt">char</span><span class="o">**</span><span class="w"> </span><span class="n">_data_pointers_</span><span class="p">;</span><span class="w">                      </span><span class="c1">///&lt; token_buffer pointers</span>
<span class="linenos">626</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_args_t</span><span class="w"> </span><span class="n">_data_pointers_index_</span><span class="p">;</span><span class="w">     </span><span class="c1">///&lt; data_pointer index</span>
<span class="linenos">627</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_args_t</span><span class="w"> </span><span class="n">_data_pointers_index_max_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; data_pointer index max</span>
<span class="linenos">628</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_args_t</span><span class="w"> </span><span class="n">_p_num_ptrs_</span><span class="p">;</span><span class="w">              </span><span class="c1">///&lt; &quot;p&quot;rocess number of pointers, computed in UserInput::begin()</span>
<span class="linenos">629</span>
<span class="linenos">630</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_args_t</span><span class="w"> </span><span class="n">_rec_num_arg_strings_</span><span class="p">;</span><span class="w">                    </span><span class="c1">///&lt; number of tokens after first valid token</span>
<span class="linenos">631</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_num_child_commands_t</span><span class="w"> </span><span class="n">_failed_on_subcommand_</span><span class="p">;</span><span class="w">     </span><span class="c1">///&lt; subcommand error index</span>
<span class="linenos">632</span><span class="w">    </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_tree_depth_per_command_t</span><span class="w"> </span><span class="n">_current_search_depth_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; current subcommand search depth</span>
<span class="linenos">633</span>
<span class="linenos">634</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">_null_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; char &#39;\0&#39;</span>
<span class="linenos">635</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">_neg_</span><span class="p">;</span><span class="w">  </span><span class="c1">///&lt; char &#39;-&#39;</span>
<span class="linenos">636</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">_dot_</span><span class="p">;</span><span class="w">  </span><span class="c1">///&lt; char &#39;.&#39;</span>
<span class="linenos">637</span>
<span class="linenos">638</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">_stream_buffer_allocated_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; this flag is set true on GetCommandFromStream entry if a buffer is not allocated</span>
<span class="linenos">639</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">_new_stream_data_</span><span class="p">;</span><span class="w">         </span><span class="c1">///&lt; if there is new data in *stream_data this is true</span>
<span class="linenos">640</span><span class="w">    </span><span class="kt">uint8_t</span><span class="o">*</span><span class="w"> </span><span class="n">_stream_data_</span><span class="p">;</span><span class="w">         </span><span class="c1">///&lt; pointer to stream input, a string of char</span>
<span class="linenos">641</span><span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">_stream_data_index_</span><span class="p">;</span><span class="w">   </span><span class="c1">///&lt; the index of stream_data</span>
<span class="linenos">642</span>
<span class="linenos">643</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">_begin_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; begin() error flag</span>
<span class="linenos">644</span>
<span class="linenos">645</span><span class="w">    </span><span class="n">InputProcessParameters</span><span class="w"> </span><span class="n">_input_prm_</span><span class="p">;</span><span class="w"> </span><span class="c1">///&lt; user input process parameters pointer struct</span>
<span class="linenos">646</span>
<span class="linenos">647</span><span class="w">    </span><span class="c1">//  end constructor initialized variables</span>
<span class="linenos">648</span>
<span class="linenos">649</span><span class="w">    </span><span class="c1">// private methods</span>
<span class="linenos">650</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">651</span><span class="cm">     * @brief UserInput vsnprintf</span>
<span class="linenos">652</span><span class="cm">     * https://www.cplusplus.com/reference/cstdio/vsprintf/</span>
<span class="linenos">653</span><span class="cm">     * @param fmt   the format string</span>
<span class="linenos">654</span><span class="cm">     * @param ...   arguments</span>
<span class="linenos">655</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">656</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">_ui_out</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">fmt</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span><span class="w"></span>
<span class="linenos">657</span>
<span class="linenos">658</span><span class="w">    </span><span class="cp">#if defined(ENABLE_readCommandFromBufferErrorOutput)</span>
<span class="linenos">659</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">660</span><span class="cm">     * @brief ReadCommandFromBuffer error output</span>
<span class="linenos">661</span><span class="cm">     *</span>
<span class="linenos">662</span><span class="cm">     * @param rprm reference to UserInput::_rcfbprm</span>
<span class="linenos">663</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">664</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">_readCommandFromBufferErrorOutput</span><span class="p">(</span><span class="n">_rcfbprm</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rprm</span><span class="p">);</span><span class="w"></span>
<span class="linenos">665</span><span class="w">    </span><span class="cp">#endif </span><span class="c1">// end ENABLE_readCommandFromBufferErrorOutput</span>
<span class="linenos">666</span>
<span class="linenos">667</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">668</span><span class="cm">     * @brief launches either (this) function or the root command function</span>
<span class="linenos">669</span><span class="cm">     *</span>
<span class="linenos">670</span><span class="cm">     * @param rprm reference to UserInput::_rcfbprm</span>
<span class="linenos">671</span><span class="cm">     * @param pname IH_pname char array</span>
<span class="linenos">672</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">673</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">_launchFunction</span><span class="p">(</span><span class="n">_rcfbprm</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rprm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">IH_pname</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pname</span><span class="p">);</span><span class="w"></span>
<span class="linenos">674</span>
<span class="linenos">675</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">676</span><span class="cm">     * @brief function launch logic, recursive on subcommand match</span>
<span class="linenos">677</span><span class="cm">     *</span>
<span class="linenos">678</span><span class="cm">     * @param rprm reference to UserInput::_rcfbprm</span>
<span class="linenos">679</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">680</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">_launchLogic</span><span class="p">(</span><span class="n">_rcfbprm</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rprm</span><span class="p">);</span><span class="w"></span>
<span class="linenos">681</span>
<span class="linenos">682</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">683</span><span class="cm">     * @brief Escapes control characters so they will print</span>
<span class="linenos">684</span><span class="cm">     *</span>
<span class="linenos">685</span><span class="cm">     * @param input the input char</span>
<span class="linenos">686</span><span class="cm">     * @param buf the output buffer</span>
<span class="linenos">687</span><span class="cm">     *</span>
<span class="linenos">688</span><span class="cm">     * @return pointer to buf, so you can use this inside of _ui_out()</span>
<span class="linenos">689</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">690</span><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">_escapeCharactersSoTheyPrint</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span><span class="w"></span>
<span class="linenos">691</span>
<span class="linenos">692</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">693</span><span class="cm">     * @brief Triggers on a control character sequence, if the char immediately</span>
<span class="linenos">694</span><span class="cm">     * after the control char is a char known to UserInput::_combineControlCharacters</span>
<span class="linenos">695</span><span class="cm">     * this returns a control char, else it returns the input char</span>
<span class="linenos">696</span><span class="cm">     *</span>
<span class="linenos">697</span><span class="cm">     * @param input the char the control character sequence</span>
<span class="linenos">698</span><span class="cm">     * @return the control character char value ie &#39;\\r&#39;</span>
<span class="linenos">699</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">700</span><span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="nf">_combineControlCharacters</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="n">input</span><span class="p">);</span><span class="w"></span>
<span class="linenos">701</span>
<span class="linenos">702</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">703</span><span class="cm">     * @brief determines if input CommandParameters struct is valid before adding to linked-list</span>
<span class="linenos">704</span><span class="cm">     *</span>
<span class="linenos">705</span><span class="cm">     * @param cmd CommandConstructor reference</span>
<span class="linenos">706</span><span class="cm">     * @param prm reference to CommandParameters struct in addCommand</span>
<span class="linenos">707</span><span class="cm">     * @return true if there are no errors</span>
<span class="linenos">708</span><span class="cm">     * @return false if there were one or more errors</span>
<span class="linenos">709</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">710</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">_addCommandAbort</span><span class="p">(</span><span class="n">CommandConstructor</span><span class="o">&amp;</span><span class="w"> </span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="n">CommandParameters</span><span class="o">&amp;</span><span class="w"> </span><span class="n">prm</span><span class="p">);</span><span class="w"></span>
<span class="linenos">711</span>
<span class="linenos">712</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">713</span><span class="cm">     * @brief Get the UITYPE equivalent for the argument, internally we use uint8_t</span>
<span class="linenos">714</span><span class="cm">     *</span>
<span class="linenos">715</span><span class="cm">     * @param prm command options structure reference</span>
<span class="linenos">716</span><span class="cm">     * @param index argument number</span>
<span class="linenos">717</span><span class="cm">     * @return UITYPE argument type</span>
<span class="linenos">718</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">719</span><span class="w">    </span><span class="n">UITYPE</span><span class="w"> </span><span class="nf">_getArgType</span><span class="p">(</span><span class="n">CommandParameters</span><span class="o">&amp;</span><span class="w"> </span><span class="n">prm</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="linenos">720</span>
<span class="linenos">721</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">722</span><span class="cm">     * @brief validate the arguments as specified in the user defined CommandParameters struct</span>
<span class="linenos">723</span><span class="cm">     *</span>
<span class="linenos">724</span><span class="cm">     * @param rprm reference to UserInput::_rcfbprm</span>
<span class="linenos">725</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">726</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">_getArgs</span><span class="p">(</span><span class="n">_rcfbprm</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rprm</span><span class="p">);</span><span class="w"></span>
<span class="linenos">727</span>
<span class="linenos">728</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">729</span><span class="cm">     * @brief adds escaped control characters to a buffer</span>
<span class="linenos">730</span><span class="cm">     *</span>
<span class="linenos">731</span><span class="cm">     * @param buf output buffer</span>
<span class="linenos">732</span><span class="cm">     * @param idx buffer index</span>
<span class="linenos">733</span><span class="cm">     * @param input string to escape</span>
<span class="linenos">734</span><span class="cm">     * @param input_len length of string</span>
<span class="linenos">735</span><span class="cm">     * @return pointer to null terminated escaped control char string</span>
<span class="linenos">736</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">737</span><span class="w">    </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="nf">_addEscapedControlCharToBuffer</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">idx</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">input_len</span><span class="p">);</span><span class="w"></span>
<span class="linenos">738</span>
<span class="linenos">739</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">740</span><span class="cm">     * @brief find delimiters in input data</span>
<span class="linenos">741</span><span class="cm">     *</span>
<span class="linenos">742</span><span class="cm">     * @param gtprm reference to getTokensParam struct in getTokens</span>
<span class="linenos">743</span><span class="cm">     * @param input_prm reference to InputProcessParameters struct</span>
<span class="linenos">744</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">745</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">_getTokensDelimiters</span><span class="p">(</span><span class="n">getTokensParam</span><span class="o">&amp;</span><span class="w"> </span><span class="n">gtprm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">InputProcessParameters</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input_prm</span><span class="p">);</span><span class="w"></span>
<span class="linenos">746</span>
<span class="linenos">747</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">748</span><span class="cm">     * @brief get delimited c-strings from input data</span>
<span class="linenos">749</span><span class="cm">     *</span>
<span class="linenos">750</span><span class="cm">     * @param gtprm reference to getTokensParam struct in getTokens</span>
<span class="linenos">751</span><span class="cm">     * @param input_prm reference to InputProcessParameters struct</span>
<span class="linenos">752</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">753</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">_getTokensStartStop</span><span class="p">(</span><span class="n">getTokensParam</span><span class="o">&amp;</span><span class="w"> </span><span class="n">gtprm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">InputProcessParameters</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input_prm</span><span class="p">);</span><span class="w"></span>
<span class="linenos">754</span>
<span class="linenos">755</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">756</span><span class="cm">     * @brief add uchar to token_buffer</span>
<span class="linenos">757</span><span class="cm">     *</span>
<span class="linenos">758</span><span class="cm">     * @param gtprm reference to getTokensParam struct in getTokens</span>
<span class="linenos">759</span><span class="cm">     * @param input_prm reference to InputProcessParameters struct</span>
<span class="linenos">760</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">761</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">_getTokensChar</span><span class="p">(</span><span class="n">getTokensParam</span><span class="o">&amp;</span><span class="w"> </span><span class="n">gtprm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">InputProcessParameters</span><span class="o">&amp;</span><span class="w"> </span><span class="n">input_prm</span><span class="p">);</span><span class="w"></span>
<span class="linenos">762</span>
<span class="linenos">763</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">764</span><span class="cm">     * @brief split a zero delimiter command, separate command and string with token delimiter for further processing</span>
<span class="linenos">765</span><span class="cm">     *</span>
<span class="linenos">766</span><span class="cm">     * @param rprm reference to UserInput::_rcfbprm</span>
<span class="linenos">767</span><span class="cm">     * @param num_zdc zero delim commands</span>
<span class="linenos">768</span><span class="cm">     * @param zdc num zdc</span>
<span class="linenos">769</span><span class="cm">     * @return true if split</span>
<span class="linenos">770</span><span class="cm">     * @return false no match no split</span>
<span class="linenos">771</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">772</span><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">_splitZDC</span><span class="p">(</span><span class="n">_rcfbprm</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rprm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_zdc</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CommandParameters</span><span class="o">**</span><span class="w"> </span><span class="n">zdc</span><span class="p">);</span><span class="w"></span>
<span class="linenos">773</span>
<span class="linenos">774</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">775</span><span class="cm">     * @brief calculates memcmp ranges for a given command around wildcard char, noninclusive</span>
<span class="linenos">776</span><span class="cm">     *</span>
<span class="linenos">777</span><span class="cm">     * @param command reference to a CommandConstructor class</span>
<span class="linenos">778</span><span class="cm">     * @param prm reference to a CommandParameters struct</span>
<span class="linenos">779</span><span class="cm">     * @param prm_idx prm index</span>
<span class="linenos">780</span><span class="cm">     * @param memcmp_ranges_idx index of memcmp_ranges</span>
<span class="linenos">781</span><span class="cm">     * @param memcmp_ranges memcmp ranges array</span>
<span class="linenos">782</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">783</span><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">_calcCmdMemcmpRanges</span><span class="p">(</span><span class="n">CommandConstructor</span><span class="o">&amp;</span><span class="w"> </span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="n">CommandParameters</span><span class="o">&amp;</span><span class="w"> </span><span class="n">prm</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">prm_idx</span><span class="p">,</span><span class="w"> </span><span class="n">IH</span><span class="o">::</span><span class="n">memcmp_idx_t</span><span class="o">&amp;</span><span class="w"> </span><span class="n">memcmp_ranges_idx</span><span class="p">,</span><span class="w"> </span><span class="n">IH</span><span class="o">::</span><span class="n">ui_max_per_cmd_memcmp_ranges_t</span><span class="o">*</span><span class="w"> </span><span class="n">memcmp_ranges</span><span class="p">);</span><span class="w"></span>
<span class="linenos">784</span>
<span class="linenos">785</span><span class="w">    </span><span class="cm">/**</span>
<span class="linenos">786</span><span class="cm">     * @brief compares (memcmp) str to cmd-&gt;prm[prm_idx].command</span>
<span class="linenos">787</span><span class="cm">     *</span>
<span class="linenos">788</span><span class="cm">     * @param cmd pointer to CommandConstructor</span>
<span class="linenos">789</span><span class="cm">     * @param prm_idx index of CommandParameters to compare</span>
<span class="linenos">790</span><span class="cm">     * @param str c-string</span>
<span class="linenos">791</span><span class="cm">     * @return UI_COMPARE match type</span>
<span class="linenos">792</span><span class="cm">     */</span><span class="w"></span>
<span class="linenos">793</span><span class="w">    </span><span class="n">UI_COMPARE</span><span class="w"> </span><span class="nf">_compareCommandToString</span><span class="p">(</span><span class="n">CommandConstructor</span><span class="o">*</span><span class="w"> </span><span class="n">cmd</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">prm_idx</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">str</span><span class="p">);</span><span class="w"></span>
<span class="linenos">794</span><span class="w">    </span><span class="c1">// end private methods</span>
<span class="linenos">795</span><span class="p">};</span><span class="w"></span>
<span class="linenos">796</span>
<span class="linenos">797</span><span class="cp">#endif </span><span class="c1">// header guard include</span>
<span class="linenos">798</span>
<span class="linenos">799</span><span class="c1">// end of file</span>
</pre></div>
</div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="../src.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Source</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Douglas Quigg (dquigg123@gmail.com)
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">InputHandler</a><ul>
<li><a class="reference internal" href="#inputhandler-h">InputHandler.h</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    </body>
</html>