<!doctype html>
<html class="no-js" lang="en">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="prev" title="Source" href="../src.html" />

    <meta name="generator" content="sphinx-5.2.0.post0, furo 2022.09.15"/>
        <title>InputHandler.h - InputHandler documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?digest=9ec31e2665bf879c1d47d93a8ec4893870ee1e45" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    
    


<style>
  body {
    --color-code-background: #f8f8f8;
  --color-code-foreground: black;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">InputHandler  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  
  
  <span class="sidebar-brand-text">InputHandler  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <p class="caption" role="heading"><span class="caption-text">Command Line Interface Generation tool reference (InputHandler.h)</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../README.html">README</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#inputhandler">InputHandler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../README.html#supported-platforms">Supported Platforms</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../src.html">Source</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle child pages in navigation</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">InputHandler.h</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section id="inputhandler-h">
<h1>InputHandler.h<a class="headerlink" href="#inputhandler-h" title="Permalink to this heading">#</a></h1>
<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv49UI_CMD_ID">
<span id="_CPPv39UI_CMD_ID"></span><span id="_CPPv29UI_CMD_ID"></span><span class="target" id="de/d8a/group___user_input_1ga166e5457949a4e09a4391b2bacbb1db0"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UI_CMD_ID</span></span></span><a class="headerlink" href="#_CPPv49UI_CMD_ID" title="Permalink to this definition">#</a><br /></dt>
<dd><p>command identifier enum this is used to explicitly state something is related to a root command in the context of UserInput::CommandParameters </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N9UI_CMD_ID4rootE">
<span id="_CPPv3N9UI_CMD_ID4rootE"></span><span id="_CPPv2N9UI_CMD_ID4rootE"></span><span class="target" id="de/d8a/group___user_input_1gga166e5457949a4e09a4391b2bacbb1db0ae87665181d83c0613d7d3fdceaa293de"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">root</span></span></span><a class="headerlink" href="#_CPPv4N9UI_CMD_ID4rootE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>this is the root command id, it’s the number 0 ALWAYS </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv410UI_WC_FLAG">
<span id="_CPPv310UI_WC_FLAG"></span><span id="_CPPv210UI_WC_FLAG"></span><span class="target" id="de/d8a/group___user_input_1gae655f6a50054ff5649f7ab9509d64f14"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UI_WC_FLAG</span></span></span><a class="headerlink" href="#_CPPv410UI_WC_FLAG" title="Permalink to this definition">#</a><br /></dt>
<dd><p>command wildcard flag enum these flags are used inside of UserInput::CommandParameters </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10UI_WC_FLAG12no_wildcardsE">
<span id="_CPPv3N10UI_WC_FLAG12no_wildcardsE"></span><span id="_CPPv2N10UI_WC_FLAG12no_wildcardsE"></span><span class="target" id="de/d8a/group___user_input_1ggae655f6a50054ff5649f7ab9509d64f14a0681c51d081bef2c026443ddb77c8127"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">no_wildcards</span></span></span><a class="headerlink" href="#_CPPv4N10UI_WC_FLAG12no_wildcardsE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>this command has no wildcard char (false (0)) </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10UI_WC_FLAG13has_wildcardsE">
<span id="_CPPv3N10UI_WC_FLAG13has_wildcardsE"></span><span id="_CPPv2N10UI_WC_FLAG13has_wildcardsE"></span><span class="target" id="de/d8a/group___user_input_1ggae655f6a50054ff5649f7ab9509d64f14aecae04b6672265aa9a4e0ec44826d67e"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">has_wildcards</span></span></span><a class="headerlink" href="#_CPPv4N10UI_WC_FLAG13has_wildcardsE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>this command contains one or more wildcard char (true (1)) </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum">
<dt class="sig sig-object cpp" id="_CPPv410UI_COMPARE">
<span id="_CPPv310UI_COMPARE"></span><span id="_CPPv210UI_COMPARE"></span><span class="target" id="de/d8a/group___user_input_1ga6d345262e77318723edf20f58dc745b6"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UI_COMPARE</span></span></span><a class="headerlink" href="#_CPPv410UI_COMPARE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>UserInput::_compareCommandToString() return values these flags are only used to provide clarity to UserInput::_compareCommandToString(), they make it easy to understand what is happening inside of that method. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10UI_COMPARE8no_matchE">
<span id="_CPPv3N10UI_COMPARE8no_matchE"></span><span id="_CPPv2N10UI_COMPARE8no_matchE"></span><span class="target" id="de/d8a/group___user_input_1gga6d345262e77318723edf20f58dc745b6aeee61f4d0c0fc1ad344a6a588f235aaf"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">no_match</span></span></span><a class="headerlink" href="#_CPPv4N10UI_COMPARE8no_matchE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>no match </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10UI_COMPARE17match_all_wcc_cmdE">
<span id="_CPPv3N10UI_COMPARE17match_all_wcc_cmdE"></span><span id="_CPPv2N10UI_COMPARE17match_all_wcc_cmdE"></span><span class="target" id="de/d8a/group___user_input_1gga6d345262e77318723edf20f58dc745b6ab79e93058f227b5f637272d3d6b40cdb"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">match_all_wcc_cmd</span></span></span><a class="headerlink" href="#_CPPv4N10UI_COMPARE17match_all_wcc_cmdE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>match all wcc command </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N10UI_COMPARE5matchE">
<span id="_CPPv3N10UI_COMPARE5matchE"></span><span id="_CPPv2N10UI_COMPARE5matchE"></span><span class="target" id="de/d8a/group___user_input_1gga6d345262e77318723edf20f58dc745b6aff192c21885a659cb1069ef9498a3069"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">match</span></span></span><a class="headerlink" href="#_CPPv4N10UI_COMPARE5matchE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>match command </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum-class">
<dt class="sig sig-object cpp" id="_CPPv415UI_ARG_HANDLING">
<span id="_CPPv315UI_ARG_HANDLING"></span><span id="_CPPv215UI_ARG_HANDLING"></span><span class="target" id="de/d8a/group___user_input_1gaaf7aee82204b26b1dc80fcefa29ea8b9"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UI_ARG_HANDLING</span></span></span><a class="headerlink" href="#_CPPv415UI_ARG_HANDLING" title="Permalink to this definition">#</a><br /></dt>
<dd><p>strongly typed argument handling flags this is used in UserInput::CommandParameters as a visual reminder of how the process will handle your arguments </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15UI_ARG_HANDLING7no_argsE">
<span id="_CPPv3N15UI_ARG_HANDLING7no_argsE"></span><span id="_CPPv2N15UI_ARG_HANDLING7no_argsE"></span><span class="target" id="de/d8a/group___user_input_1ggaaf7aee82204b26b1dc80fcefa29ea8b9a517c5dac9a168ab48e4727ca5ada9741"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">no_args</span></span></span><a class="headerlink" href="#_CPPv4N15UI_ARG_HANDLING7no_argsE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>no arguments expected </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15UI_ARG_HANDLING8one_typeE">
<span id="_CPPv3N15UI_ARG_HANDLING8one_typeE"></span><span id="_CPPv2N15UI_ARG_HANDLING8one_typeE"></span><span class="target" id="de/d8a/group___user_input_1ggaaf7aee82204b26b1dc80fcefa29ea8b9afd1b59a959f982928e0b4e79bb42dd67"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">one_type</span></span></span><a class="headerlink" href="#_CPPv4N15UI_ARG_HANDLING8one_typeE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>every argument is of the same type </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N15UI_ARG_HANDLING8type_arrE">
<span id="_CPPv3N15UI_ARG_HANDLING8type_arrE"></span><span id="_CPPv2N15UI_ARG_HANDLING8type_arrE"></span><span class="target" id="de/d8a/group___user_input_1ggaaf7aee82204b26b1dc80fcefa29ea8b9aad69e504bf949689b02f44ff8246d98f"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">type_arr</span></span></span><a class="headerlink" href="#_CPPv4N15UI_ARG_HANDLING8type_arrE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>there is an array of input types </p>
</dd></dl>

</dd></dl>

<dl class="cpp enum-class">
<dt class="sig sig-object cpp" id="_CPPv46UITYPE">
<span id="_CPPv36UITYPE"></span><span id="_CPPv26UITYPE"></span><span class="target" id="de/d8a/group___user_input_1ga70e7c464dbd2c5c26fa63684d9dfdd70"></span><span class="k"><span class="pre">enum</span></span><span class="w"> </span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UITYPE</span></span></span><a class="headerlink" href="#_CPPv46UITYPE" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#dc/d4b/class_user_input"><span class="std std-ref">UserInput</span></a> type specifier these are the different types of user input the process can accept NOTYPE and START_STOP can be any 0-255 value This is strongly typed to help avoid name conflicts, and as an indicator that these types are not built-in. </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE7UINT8_TE">
<span id="_CPPv3N6UITYPE7UINT8_TE"></span><span id="_CPPv2N6UITYPE7UINT8_TE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70a25185a78b19f8b194e2955929e32baca"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UINT8_T</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE7UINT8_TE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>8-bit unsigned integer </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE8UINT16_TE">
<span id="_CPPv3N6UITYPE8UINT16_TE"></span><span id="_CPPv2N6UITYPE8UINT16_TE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70abd93e66a884d0291f3db5bb0eeb03ffe"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UINT16_T</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE8UINT16_TE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>16-bit unsigned integer </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE8UINT32_TE">
<span id="_CPPv3N6UITYPE8UINT32_TE"></span><span id="_CPPv2N6UITYPE8UINT32_TE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70abc0d406b455d82bfc780c67be1976fed"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UINT32_T</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE8UINT32_TE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>32-bit unsigned integer </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE7INT16_TE">
<span id="_CPPv3N6UITYPE7INT16_TE"></span><span id="_CPPv2N6UITYPE7INT16_TE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70a5e66c6e44fda6975bc1d1f10f4ea0436"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">INT16_T</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE7INT16_TE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>16-bit signed integer </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE5FLOATE">
<span id="_CPPv3N6UITYPE5FLOATE"></span><span id="_CPPv2N6UITYPE5FLOATE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70ae738c26bf4ce1037fa81b039a915cbf6"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">FLOAT</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE5FLOATE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>32-bit float </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE4CHARE">
<span id="_CPPv3N6UITYPE4CHARE"></span><span id="_CPPv2N6UITYPE4CHARE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70a027acd3aa6b1dd7f26119d3cf0f9a063"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CHAR</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE4CHARE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>8-bit char </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE10START_STOPE">
<span id="_CPPv3N6UITYPE10START_STOPE"></span><span id="_CPPv2N6UITYPE10START_STOPE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70af749dae7024a2aceb2b15cb807300aef"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">START_STOP</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE10START_STOPE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>array of 8-bit char </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE6NOTYPEE">
<span id="_CPPv3N6UITYPE6NOTYPEE"></span><span id="_CPPv2N6UITYPE6NOTYPEE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70a0323d2829f046f18b7dbcc0f58f941bc"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NOTYPE</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE6NOTYPEE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>no type validation </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE7NO_ARGSE">
<span id="_CPPv3N6UITYPE7NO_ARGSE"></span><span id="_CPPv2N6UITYPE7NO_ARGSE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70acd158bf723602ecc6429b5771682a716"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">NO_ARGS</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE7NO_ARGSE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>no arguments expected </p>
</dd></dl>

<dl class="cpp enumerator">
<dt class="sig sig-object cpp" id="_CPPv4N6UITYPE5_LASTE">
<span id="_CPPv3N6UITYPE5_LASTE"></span><span id="_CPPv2N6UITYPE5_LASTE"></span><span class="target" id="de/d8a/group___user_input_1gga70e7c464dbd2c5c26fa63684d9dfdd70aaa55687588914f1c2a506982d7f57948"></span><span class="k"><span class="pre">enumerator</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_LAST</span></span></span><a class="headerlink" href="#_CPPv4N6UITYPE5_LASTE" title="Permalink to this definition">#</a><br /></dt>
<dd><p>reserved </p>
</dd></dl>

</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp">
<span class="target" id="de/d8a/group___user_input_1ga08f01b3963da682b202040cdf718ea11"></span><span class="sig-name descname"><span class="pre">const</span> <span class="pre">PROGMEM</span> <span class="pre">char</span> <span class="pre">UserInput_type_strings_pgm</span> <span class="pre">[10][UI_INPUT_TYPE_STRINGS_PGM_LEN]</span> <span class="pre">=</span> <span class="pre">{&quot;UINT8_T&quot;,&quot;UINT16_T&quot;,&quot;UINT32_T&quot;,&quot;INT16_T&quot;,&quot;FLOAT&quot;,&quot;CHAR&quot;,&quot;STARTSTOP&quot;,&quot;NOTYPE&quot;,&quot;NO_ARGS&quot;,&quot;error&quot;}</span></span></dt>
<dd><p>type string literals input type string literal PROGMEM array, each of the types in UITYPE has a corresponding string literal for display purposes </p>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv430InputProcessDelimiterSequences">
<span id="_CPPv330InputProcessDelimiterSequences"></span><span id="_CPPv230InputProcessDelimiterSequences"></span><span id="InputProcessDelimiterSequences"></span><span class="target" id="dc/da2/struct_input_process_delimiter_sequences"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InputProcessDelimiterSequences</span></span></span><a class="headerlink" href="#_CPPv430InputProcessDelimiterSequences" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#dc/da2/struct_input_process_delimiter_sequences"><span class="std std-ref">InputProcessDelimiterSequences</span></a> struct holds user defined input data delimiters This struct holds information about the delimiter sequences the process will be using. A delimiter sequence is a predefined number or set of numbers that is used to separate input arguments, subcommands or data. The input process needs to know three things about the delimiter sequences you want to use. The number of delimiter sequences there are (up to UI_MAX_DELIM_SEQ), the 8-bit byte (char) length of each delimiter sequence, and finally each delimiter sequence which can be up to UI_DELIM_SEQ_PGM_LEN in length. </p>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv430InputProcessStartStopSequences">
<span id="_CPPv330InputProcessStartStopSequences"></span><span id="_CPPv230InputProcessStartStopSequences"></span><span id="InputProcessStartStopSequences"></span><span class="target" id="d4/dc0/struct_input_process_start_stop_sequences"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InputProcessStartStopSequences</span></span></span><a class="headerlink" href="#_CPPv430InputProcessStartStopSequences" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#d4/dc0/struct_input_process_start_stop_sequences"><span class="std std-ref">InputProcessStartStopSequences</span></a> struct holds regex-like start-stop match sequence pairs This struct holds information about the start-stop sequence pairs the process will be using. A start-stop sequence is a pair of numbers or a pair of a set of numbers which do not have to be identical to one another. The “start” sequence demarcs the beginning of a chunk of data, the “stop” sequence demarcs the end of the chunk of data. The input process needs to know three things about the start-stop sequences you want to use. The number of start-stop sequences there are (up to UI_MAX_START_STOP_SEQ), the 8-bit byte (char) length of each start-stop sequence, and finally each start-stop sequence which can be up to UI_START_STOP_SEQ_PGM_LEN in length. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv48IH_pname">
<span id="_CPPv38IH_pname"></span><span id="_CPPv28IH_pname"></span><span id="IH_pname"></span><span class="target" id="de/d8a/group___user_input_1ga561fa7484e19f7dfebcf361ecd585f2f"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IH_pname</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">UI_PROCESS_NAME_PGM_LEN</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv48IH_pname" title="Permalink to this definition">#</a><br /></dt>
<dd><p>IH_pname is a char array typedef the size of UI_PROCESS_NAME_PGM_LEN This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv46IH_eol">
<span id="_CPPv36IH_eol"></span><span id="_CPPv26IH_eol"></span><span id="IH_eol"></span><span class="target" id="de/d8a/group___user_input_1gafbde6b816485ab1d1e6e22b3b0cb9f02"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IH_eol</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">UI_EOL_SEQ_PGM_LEN</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv46IH_eol" title="Permalink to this definition">#</a><br /></dt>
<dd><p>IH_eol is a char array typedef the size of UI_EOL_SEQ_PGM_LEN This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv411IH_input_cc">
<span id="_CPPv311IH_input_cc"></span><span id="_CPPv211IH_input_cc"></span><span id="IH_input_cc"></span><span class="target" id="de/d8a/group___user_input_1ga85f676c44db484981373328e3dbf0698"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IH_input_cc</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">UI_INPUT_CONTROL_CHAR_SEQ_PGM_LEN</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv411IH_input_cc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>IH_input_cc is a char array typedef the size of UI_INPUT_CONTROL_CHAR_SEQ_PGM_LEN This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h. </p>
</dd></dl>

<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv46IH_wcc">
<span id="_CPPv36IH_wcc"></span><span id="_CPPv26IH_wcc"></span><span id="IH_wcc"></span><span class="target" id="de/d8a/group___user_input_1gae5ba9d1632e0bccd924cf01102d0af3d"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">IH_wcc</span></span></span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">]</span></span><a class="headerlink" href="#_CPPv46IH_wcc" title="Permalink to this definition">#</a><br /></dt>
<dd><p>IH_wcc is a two char array that represents the wildcard char and a null terminator This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h. </p>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv422InputProcessParameters">
<span id="_CPPv322InputProcessParameters"></span><span id="_CPPv222InputProcessParameters"></span><span id="InputProcessParameters"></span><span class="target" id="db/dda/struct_input_process_parameters"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">InputProcessParameters</span></span></span><a class="headerlink" href="#_CPPv422InputProcessParameters" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#dc/d4b/class_user_input"><span class="std std-ref">UserInput</span></a> input process parameters, constructor parameters This struct is an array of pointers to other structs/arrays contained in PROGMEM It’s required by the input process, all together they define the input process behavior. </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp">
<span class="target" id="de/d8a/group___user_input_1gae02e75f336946c2667c75c61b302baeb"></span><span class="sig-name descname"><span class="pre">const</span> <span class="pre">PROGMEM</span> <span class="pre">IH_pname</span> <span class="pre">_pname</span>&#160;&#160; <span class="pre">=</span> <span class="pre">&quot;&quot;</span></span></dt>
<dd><p>default process name == “” </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp">
<span class="target" id="de/d8a/group___user_input_1ga648dd8cd47317e8f8764a383f85b4d52"></span><span class="sig-name descname"><span class="pre">const</span> <span class="pre">PROGMEM</span> <span class="pre">IH_eol</span> <span class="pre">_peol</span>&#160;&#160; <span class="pre">=</span> <span class="pre">&quot;\r\n&quot;</span></span></dt>
<dd><p>default process eol characters “\r\n” </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp">
<span class="target" id="de/d8a/group___user_input_1gae949edb22aa21bc0604c634a238ebb6d"></span><span class="sig-name descname"><span class="pre">const</span> <span class="pre">PROGMEM</span> <span class="pre">IH_input_cc</span> <span class="pre">_pinputcc</span>&#160;&#160; <span class="pre">=</span> <span class="pre">&quot;##&quot;</span></span></dt>
<dd><p>default process input control character sequence “##” </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp">
<span class="target" id="de/d8a/group___user_input_1ga4aaf7ae99900377fc18b6ac5631c21de"></span><span class="sig-name descname"><span class="pre">const</span> <span class="pre">PROGMEM</span> <span class="pre">IH_wcc</span> <span class="pre">_pwcc</span>&#160;&#160; <span class="pre">=</span> <span class="pre">&quot;*&quot;</span></span></dt>
<dd><p>default process wildcard char ‘*’ </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp">
<span class="target" id="de/d8a/group___user_input_1ga2a598377b17768e0e9bb3be40f439c3a"></span><span class="sig-name descname"><span class="pre">const</span> <span class="pre">PROGMEM</span> <span class="pre">InputProcessDelimiterSequences</span> <span class="pre">_pdelimseq</span>&#160; <span class="pre">=</span> <span class="pre">{2,{1,</span> <span class="pre">1},{&quot;</span> <span class="pre">&quot;,</span> <span class="pre">&quot;,&quot;}}</span></span></dt>
<dd><p>default delimiter sequences </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp">
<span class="target" id="de/d8a/group___user_input_1ga43c58059001edf0ce5f70fb14817c504"></span><span class="sig-name descname"><span class="pre">const</span> <span class="pre">PROGMEM</span> <span class="pre">InputProcessStartStopSequences</span> <span class="pre">_pststpseq</span>&#160; <span class="pre">=</span> <span class="pre">{1,{1,</span> <span class="pre">1},{&quot;\&quot;&quot;,</span> <span class="pre">&quot;\&quot;&quot;}}</span></span></dt>
<dd><p>default start stop sequences </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp">
<span class="target" id="de/d8a/group___user_input_1ga1b8250d1ff59794560036a419e0423b8"></span><span class="sig-name descname"><span class="pre">const</span> <span class="pre">PROGMEM</span> <span class="pre">InputProcessParameters</span> <span class="pre">_DEFAULT_UI_INPUT_PRM_</span>&#160; <span class="pre">=</span> <span class="pre">{&amp;_pname,&amp;_peol,&amp;_pinputcc,&amp;_pwcc,&amp;_pdelimseq,&amp;_pststpseq</span>&#160;&#160; <span class="pre">}</span></span></dt>
<dd><p><a class="reference internal" href="#dc/d4b/class_user_input"><span class="std std-ref">UserInput</span></a> default <a class="reference internal" href="#db/dda/struct_input_process_parameters"><span class="std std-ref">InputProcessParameters</span></a>. </p>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv418CommandRuntimeCalc">
<span id="_CPPv318CommandRuntimeCalc"></span><span id="_CPPv218CommandRuntimeCalc"></span><span id="CommandRuntimeCalc"></span><span class="target" id="dc/d3d/struct_command_runtime_calc"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CommandRuntimeCalc</span></span></span><a class="headerlink" href="#_CPPv418CommandRuntimeCalc" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#dc/d3d/struct_command_runtime_calc"><span class="std std-ref">CommandRuntimeCalc</span></a> struct contains arrays and indices determined at runtime these structs are associated with wildcard commands; every <a class="reference internal" href="#df/d68/class_command_constructor"><span class="std std-ref">CommandConstructor</span></a> that has a <a class="reference internal" href="#db/d11/struct_command_parameters"><span class="std std-ref">CommandParameters</span></a> which contains wildcards will have a <a class="reference internal" href="#dc/d3d/struct_command_runtime_calc"><span class="std std-ref">CommandRuntimeCalc</span></a>. </p>
</dd></dl>

<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv417CommandParameters">
<span id="_CPPv317CommandParameters"></span><span id="_CPPv217CommandParameters"></span><span id="CommandParameters"></span><span class="target" id="db/d11/struct_command_parameters"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CommandParameters</span></span></span><a class="headerlink" href="#_CPPv417CommandParameters" title="Permalink to this definition">#</a><br /></dt>
<dd><p><a class="reference internal" href="#db/d11/struct_command_parameters"><span class="std std-ref">CommandParameters</span></a> struct, this is the container that holds your command parameters. </p>
<p>Every command and subcommand has an associated <a class="reference internal" href="#db/d11/struct_command_parameters"><span class="std std-ref">CommandParameters</span></a> object, this is the information that the input process needs to know about your command </p>
</dd></dl>

<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv418CommandConstructor">
<span id="_CPPv318CommandConstructor"></span><span id="_CPPv218CommandConstructor"></span><span id="CommandConstructor"></span><span class="target" id="df/d68/class_command_constructor"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">CommandConstructor</span></span></span><a class="headerlink" href="#_CPPv418CommandConstructor" title="Permalink to this definition">#</a><br /></dt>
<dd><p>user command constructor class </p>
</dd></dl>

<dl class="cpp class">
<dt class="sig sig-object cpp" id="_CPPv49UserInput">
<span id="_CPPv39UserInput"></span><span id="_CPPv29UserInput"></span><span id="UserInput"></span><span class="target" id="dc/d4b/class_user_input"></span><span class="k"><span class="pre">class</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">UserInput</span></span></span><a class="headerlink" href="#_CPPv49UserInput" title="Permalink to this definition">#</a><br /></dt>
<dd><p>User input handler methods. </p>
</dd></dl>

<section id="id1">
<h2>InputHandler.h<a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h2>
<div class="literal-block-wrapper docutils container" id="id2">
<div class="code-block-caption"><span class="caption-text">src/InputHandler.h</span><a class="headerlink" href="#id2" title="Permalink to this code">#</a></div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>/**
 * @file InputHandler.h
 * @author Douglas Quigg (dstroy0 dquigg123@gmail.com)
 * @brief InputHandler library header file
 * @version 1.1
 * @date 2022-05-28
 *
 * @copyright Copyright (c) 2022
 */
/*
 Copyright (C) 2022 Douglas Quigg (dstroy0) &lt;dquigg123@gmail.com&gt;

 This program is free software; you can redistribute it and/or
 modify it under the terms of the GNU General Public License
 version 3 as published by the Free Software Foundation.
 */
#if !defined(__USER_INPUT_HANDLER_H__)
    #define __USER_INPUT_HANDLER_H__

    // user configurable items located in src/config/config.h and src/config/advanced_config.h
    // see examples/all_platforms/advanced/GetCommandFromStream.ino for an example
    #include &quot;config/noedit.h&quot;

/**
 * @defgroup UserInput class constants
 * @{
 */

/**
 * @brief command identifier enum
 * this is used to explicitly state something is related to a root command
 * in the context of UserInput::CommandParameters
 * @enum UI_CMD_ID
 */
enum UI_CMD_ID
{
    root ///&lt; this is the root command id, it&#39;s the number 0 ALWAYS
};

/**
 * @brief command wildcard flag enum
 * these flags are used inside of UserInput::CommandParameters
 * @enum UI_WC_FLAG
 */
enum UI_WC_FLAG
{
    no_wildcards = false, ///&lt; this command has no wildcard char (false (0))
    has_wildcards = true  ///&lt; this command contains one or more wildcard char (true (1))
};

/**
 * @brief UserInput::_compareCommandToString() return values
 * these flags are only used to provide clarity to UserInput::_compareCommandToString(),
 * they make it easy to understand what is happening inside of that method
 * @enum UI_COMPARE
 *
 */
enum UI_COMPARE
{
    no_match,          ///&lt; no match
    match_all_wcc_cmd, ///&lt; match all wcc command
    match              ///&lt; match command
};

/**
 * @brief strongly typed argument handling flags
 * this is used in UserInput::CommandParameters as a visual reminder of
 * how the process will handle your arguments
 * @enum UI_ARG_HANDLING
 */
enum class UI_ARG_HANDLING
{
    no_args,  ///&lt;  no arguments expected
    one_type, ///&lt;  every argument is of the same type
    type_arr  ///&lt;  there is an array of input types
};

/**
 * @brief UserInput type specifier
 * these are the different types of user input the process can accept
 * NOTYPE and START_STOP can be any 0-255 value
 * This is strongly typed to help avoid name conflicts, and as an indicator that
 * these types are not built-in.
 * @enum UITYPE
 */
enum class UITYPE
{
    UINT8_T,    ///&lt;  8-bit unsigned integer
    UINT16_T,   ///&lt;  16-bit unsigned integer
    UINT32_T,   ///&lt;  32-bit unsigned integer
    INT16_T,    ///&lt;  16-bit signed integer
    FLOAT,      ///&lt;  32-bit float
    CHAR,       ///&lt;  8-bit char
    START_STOP, ///&lt;  array of 8-bit char
    NOTYPE,     ///&lt;  no type validation
    NO_ARGS,    ///&lt;  no arguments expected
    _LAST       ///&lt;  reserved
};

/**
 * @brief type string literals
 * input type string literal PROGMEM array, each of the types in UITYPE has
 * a corresponding string literal for display purposes
 */
const PROGMEM char UserInput_type_strings_pgm[10][UI_INPUT_TYPE_STRINGS_PGM_LEN] = {
    &quot;UINT8_T&quot;,   // 8-bit unsigned integer
    &quot;UINT16_T&quot;,  // 16-bit unsigned integer
    &quot;UINT32_T&quot;,  // 32-bit unsigned integer
    &quot;INT16_T&quot;,   // 16-bit signed integer
    &quot;FLOAT&quot;,     // 32-bit floating point number
    &quot;CHAR&quot;,      // single char
    &quot;STARTSTOP&quot;, // c-string enclosed with start/stop delimiters
    &quot;NOTYPE&quot;,    // user defined NOTYPE
    &quot;NO_ARGS&quot;,   // no arguments expected
    &quot;error&quot;      // error
};

/**
 * @brief InputProcessDelimiterSequences struct holds user defined input data delimiters
 * This struct holds information about the delimiter sequences the process will be using.
 * A delimiter sequence is a predefined number or set of numbers that is used to separate
 * input arguments, subcommands or data.  The input process needs to know three things
 * about the delimiter sequences you want to use.  The number of delimiter sequences there are
 * (up to UI_MAX_DELIM_SEQ), the 8-bit byte (char) length of each delimiter sequence, and
 * finally each delimiter sequence which can be up to UI_DELIM_SEQ_PGM_LEN in length.
 */
struct InputProcessDelimiterSequences
{
    size_t num_seq;                                                       ///&lt; the number of token delimiters in delimiter_sequences
    IH::ui_max_num_delim_seq_t delimiter_lens[UI_MAX_NUM_DELIM_SEQ];      ///&lt; delimiter sequence lens
    char delimiter_sequences[UI_MAX_NUM_DELIM_SEQ][UI_DELIM_SEQ_PGM_LEN]; ///&lt; string-literal &quot;&quot; delimiter sequence array
};

/**
 * @brief InputProcessStartStopSequences struct holds regex-like start-stop match sequence pairs
 * This struct holds information about the start-stop sequence pairs the process will be using.
 * A start-stop sequence is a pair of numbers or a pair of a set of numbers which do not have to
 * be identical to one another.  The &quot;start&quot; sequence demarcs the beginning of a chunk of data,
 * the &quot;stop&quot; sequence demarcs the end of the chunk of data. The input process needs to know
 * three things about the start-stop sequences you want to use.  The number of start-stop
 * sequences there are (up to UI_MAX_START_STOP_SEQ), the 8-bit byte (char) length of each
 * start-stop sequence, and finally each start-stop sequence which can be up to
 * UI_START_STOP_SEQ_PGM_LEN in length.
 */
struct InputProcessStartStopSequences
{
    size_t num_seq;                                                                       ///&lt; num start/stop sequences
    IH::ui_max_num_start_stop_seq_t start_stop_sequence_lens[UI_MAX_NUM_START_STOP_SEQ];  ///&lt; start stop sequence lens
    char start_stop_sequence_pairs[UI_MAX_NUM_START_STOP_SEQ][UI_START_STOP_SEQ_PGM_LEN]; ///&lt; start/stop sequences.  Match start, match end, copy what is between
};

/**
 * @brief IH_pname is a char array typedef the size of UI_PROCESS_NAME_PGM_LEN
 * This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h
 */
typedef char IH_pname[UI_PROCESS_NAME_PGM_LEN];

/**
 * @brief IH_eol is a char array typedef the size of UI_EOL_SEQ_PGM_LEN
 * This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h
 */
typedef char IH_eol[UI_EOL_SEQ_PGM_LEN];

/**
 * @brief IH_input_cc is a char array typedef the size of UI_INPUT_CONTROL_CHAR_SEQ_PGM_LEN
 * This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h
 */
typedef char IH_input_cc[UI_INPUT_CONTROL_CHAR_SEQ_PGM_LEN];

/**
 * @brief IH_wcc is a two char array that represents the wildcard char and a null terminator
 * This is a char array, you can change the macro in src/config/InputHandler_PROGMEM_settings.h
 */
typedef char IH_wcc[2];

/**
 * @brief UserInput input process parameters, constructor parameters
 * This struct is an array of pointers to other structs/arrays contained in PROGMEM
 * It&#39;s required by the input process, all together they define the input process behavior
 */
struct InputProcessParameters
{
    const IH_pname* pname;                           ///&lt; this process&#39; name, can be NULL; MAX len == UI_PROCESS_NAME_PGM_LEN
    const IH_eol* peol;                              ///&lt; end of line term; MAX len == UI_EOL_SEQ_PGM_LEN
    const IH_input_cc* pinputcc;                     ///&lt; two char len sequence to input a control char
    const IH_wcc* pwcc;                              ///&lt; single char wildcard char
    const InputProcessDelimiterSequences* pdelimseq; ///&lt; reference to InputProcessDelimiterSequences struct
    const InputProcessStartStopSequences* pststpseq; ///&lt; reference to InputProcessStartStopSequences struct
};

const PROGMEM IH_pname _pname = &quot;&quot;;         ///&lt; default process name == &quot;&quot;
const PROGMEM IH_eol _peol = &quot;\r\n&quot;;        ///&lt; default process eol characters &quot;\\r\\n&quot;
const PROGMEM IH_input_cc _pinputcc = &quot;##&quot;; ///&lt; default process input control character sequence &quot;##&quot;
const PROGMEM IH_wcc _pwcc = &quot;*&quot;;           ///&lt; default process wildcard char &#39;*&#39;

/**
 * @brief default delimiter sequences
 *
 */
const PROGMEM InputProcessDelimiterSequences _pdelimseq = {
    2,         ///&lt; default number of delimiter sequences
    {1, 1},    ///&lt; default delimiter sequence lens
    {&quot; &quot;, &quot;,&quot;} ///&lt; default delimiter sequences
};

/**
 * @brief default start stop sequences
 *
 */
const PROGMEM InputProcessStartStopSequences _pststpseq = {
    1,           ///&lt; default num start stop sequence pairs
    {1, 1},      ///&lt; default start stop sequence lens
    {&quot;\&quot;&quot;, &quot;\&quot;&quot;} ///&lt; default start stop sequence pair sequences
};

/**
 * @brief UserInput default InputProcessParameters
 *
 */
const PROGMEM InputProcessParameters _DEFAULT_UI_INPUT_PRM_ = {
    &amp;_pname,     ///&lt; default process name
    &amp;_peol,      ///&lt; default process eol term
    &amp;_pinputcc,  ///&lt; default process input control char sequence
    &amp;_pwcc,      ///&lt; default process wildcard char
    &amp;_pdelimseq, ///&lt; default process default delimiter sequences
    &amp;_pststpseq  ///&lt; default process default start/stop sequences
};

/**
 * @brief CommandRuntimeCalc struct contains arrays and indices determined at runtime
 * these structs are associated with wildcard commands; every CommandConstructor
 * that has a CommandParameters which contains wildcards will have a CommandRuntimeCalc
 */
struct CommandRuntimeCalc
{
    IH::memcmp_idx_t num_prm_with_wc;                    ///&lt; the number of CommandParameters structs in this command that contain char(IH_wcc[0]); the WildCard Character
    IH::memcmp_idx_t* idx_of_prm_with_wc;                ///&lt; indices of CommandParameters struct that contain wcc
    IH::ui_max_per_cmd_memcmp_ranges_t* num_memcmp_ranges_this_row; ///&lt; the number of memcmp ranges for this Parameters command string, array members always an even number
    IH::ui_max_per_cmd_memcmp_ranges_t** memcmp_ranges_arr;         ///&lt; 2d array[row][col], each [row] is for one Parameters command string which contains wcc
};

/**
 * @brief forward declaration of UserInput class for
 * CommandParameters struct and CommandConstructor class
 */
class UserInput;

/**
 * @brief CommandParameters struct, this is the container that holds your command parameters
 *
 * Every command and subcommand has an associated CommandParameters object, this is the information
 * that the input process needs to know about your command
 */
struct CommandParameters
{
    void (*function)(UserInput*);                 ///&lt; void function pointer, void your_function(UserInput *inputProcess)
    bool has_wildcards;                           ///&lt; if true this command has one or more wildcard char
    char command[UI_MAX_CMD_LEN + 1U];            ///&lt; command string + &#39;\0&#39;
    IH::ui_max_cmd_len_t command_length;          ///&lt; command length in characters
    IH::cmd_id_grp_t parent_command_id;           ///&lt; parent command&#39;s unique id root-MAX
    IH::cmd_id_grp_t command_id;                  ///&lt; this command&#39;s unique id root-MAX
    IH::ui_max_tree_depth_per_command_t depth;    ///&lt; command tree depth root-MAX
    IH::ui_max_num_child_commands_t sub_commands; ///&lt; how many subcommands does this command have 0 - UI_MAX_SUBCOMMANDS
    UI_ARG_HANDLING argument_flag;                ///&lt; argument handling flag
    IH::ui_max_args_t num_args;                   ///&lt; minimum number of arguments this command expects 0 - UI_MAX_ARGS
    IH::ui_max_args_t max_num_args;               ///&lt; maximum number of arguments this command expects 0 - UI_MAX_ARGS, cannot be less than num_args
    UITYPE arg_type_arr[UI_MAX_ARGS_PER_COMMAND]; ///&lt; argument UITYPE array
};
/** @} */

/**
 * @brief user command constructor class
 */
class CommandConstructor
{
public:
    /**
     * @brief CommandConstructor Constructor
     *
     * Linked-list primer: https://www.programiz.com/dsa/linked-list
     *
     * These constructors are chained together as a linked-list; this CommandConstructor
     * object contains a reference CommandConstructor::next_command to the next node
     * in the linked-list.  The list is linked together in UserInput::addCommand().
     *
     * Before using, construct a UserInput object and a CommandParameters object.
     * @param parameters pointer to parameters struct or array of parameters structs
     * @param parameter_array_elements number of elements in the parameter array
     * @param tree_depth depth of command tree
     */
    CommandConstructor(const CommandParameters* parameters, const IH::ui_max_commands_in_tree_t parameter_array_elements = 1, const IH::ui_max_tree_depth_per_command_t tree_depth = 0)
        : prm(parameters),
          param_array_len(parameter_array_elements),
          tree_depth(tree_depth + 1U),
          calc(NULL),
          next_command(NULL)
    {
    }
    const CommandParameters* prm;                        ///&lt; pointer to PROGMEM CommandParameters array
    const IH::ui_max_commands_in_tree_t param_array_len; ///&lt; user input param array len, either as digits or through nprms
    const IH::ui_max_commands_in_tree_t tree_depth;      ///&lt; user input depth + 1
    CommandRuntimeCalc* calc;                            ///&lt; pointer to CommandRuntimeCalc struct
    CommandConstructor* next_command;                    ///&lt; CommandConstructor iterator/pointer
};

/**
 * @brief User input handler methods
 */
class UserInput
{
public:
    /**
     * @name UserInput class
     */

    /**
     * @brief UserInput constructor, no output by default
     *
     * UserInput has no output by default due to the default values passed in by the constructor.
     * The constructor disables output by setting `_output_enabled_` to false if output_buffer is
     * NULL.
     *
     * @param input_prm InputProcessParameters struct pointer.  NULL by default, which causes the ctor to use _DEFAULT_UI_INPUT_PRM_ unless you define your own
     * @param output_buffer class output char buffer, implementation specific.  NULL by default.
     * @param output_buffer_len size of output_buffer buffsz(output_buffer)     
     */
    UserInput(const InputProcessParameters* input_prm = NULL, char* output_buffer = NULL, size_t output_buffer_len = 0)
        : _input_prm_ptr_((input_prm == NULL) ? &amp;_DEFAULT_UI_INPUT_PRM_ : input_prm),
          _output_buffer_(output_buffer),
          _output_buffer_len_(output_buffer_len),          
          _output_enabled_((output_buffer == NULL) ? false : true),
          _output_buffer_bytes_left_(output_buffer_len),
          _term_len_(strlen_P(((input_prm == NULL) ? (char*)_DEFAULT_UI_INPUT_PRM_.peol : (char*)input_prm-&gt;peol))),
          _term_index_(0),
          _default_function_(NULL),
          _commands_head_(NULL),
          _commands_tail_(NULL),
          _commands_count_(0),
          _max_depth_(0),
          _max_args_(0),
          _input_type_match_flags_(NULL),
          _output_flag_(false),
          _token_buffer_(NULL),
          _data_pointers_(NULL),
          _data_pointers_index_(0),
          _data_pointers_index_max_(0),
          _p_num_ptrs_(0),
          _rec_num_arg_strings_(0),
          _failed_on_subcommand_(0),
          _current_search_depth_(1),
          _null_(&#39;\0&#39;),
          _neg_(&#39;-&#39;),
          _dot_(&#39;.&#39;),
          _stream_buffer_allocated_(false),
          _new_stream_data_(false),
          _stream_data_(NULL),
          _stream_data_index_(0),
          _begin_(false)
    {
        memcpy_P(&amp;_input_prm_, _input_prm_ptr_, sizeof(_input_prm_));
    }

    /**
     * @brief Sets the _default_function_ pointer
     * When there is no command match, or when input is invalid, this function is called
     * if the pointer is not NULL
     *
     * @param function a pointer to a user specified default function
     */
    void defaultFunction(void (*function)(UserInput*));

    /**
     * @brief adds user commands to the input process
     *
     * This function inspects CommandParameters for errors and
     * reports the errors to the user if they have enabled output.
     * If an error is detected in the root command or any of
     * its subcommands, the entire command tree is rejected,
     * and sizing for dynamically allocated variables does not
     * take place.
     *
     * @param command reference to CommandConstructor object
     */
    void addCommand(CommandConstructor&amp; command);

    /**
     * @brief Allocates memory for _data_pointers_ and _input_type_match_flags_, sets _begin_
     *
     * @return true if allocation successful
     * @return false if allocation unsuccessful
     */
    bool begin();

    #if defined(ENABLE_listSettings)
    /**
     * @brief Lists UserInput class settings, useful for implementation debugging. REQUIRES 570 byte output_buffer.
     *
     * Lists all pertinient process information:
     * class configuration, constructor variables,
     * and the amount of pointers that were dynamically
     * allocated in UserInput::begin()
     *
     * REQUIRES a 650 byte output_buffer.  If an insufficient buffer size is declared,
     * UserInput::_ui_out() will warn the user to increase the buffer to the required size.
     *
     * @param inputProcess pointer to class instance
     */
    void listSettings(UserInput* inputProcess);
    #endif

    #if defined(ENABLE_listCommands)
    /**
     * @brief Lists commands that will respond to user input if `_begin_` == true
     * else it will inform the user to use begin() in setup()
     */
    void listCommands();
    #endif

    /**
     * @brief Used internally by UserInput::readCommandFromBuffer() and passed by reference
     *
     */
    struct _rcfbprm
    {
        bool launch_attempted;           ///&lt; function launch attempted if true
        bool command_matched;            ///&lt; matched root command if true
        bool all_arguments_valid;        ///&lt; argument error sentinel
        bool subcommand_matched;         ///&lt; matched a subcommand
        CommandConstructor* cmd;         ///&lt; pointer to CommandConstructor
        CommandConstructor* all_wcc_cmd; ///&lt; pointer to CommandConstructor
        UI_COMPARE result;               ///&lt; result of UserInput::_compareCommandToString()
        IH::cmd_id_grp_t command_id;     ///&lt; type set by macro
        size_t idx;                      ///&lt; CommandParameters index
        size_t all_wcc_idx;              ///&lt; index of CommandParameters that has an all wcc command
        size_t input_len;                ///&lt; length of input data
        size_t token_buffer_len;         ///&lt; length of token buffer
        size_t tokens_received;          ///&lt; how many tokens we received
        CommandParameters prm;           ///&lt; CommandParameters struct
        uint8_t* input_data;             ///&lt; pointer to input_data
        uint8_t* split_input;            ///&lt; pointer to UserInput::_splitZDC() modified data
    };

    /**
     * @brief read command(s) from a uint8_t (unsigned char) buffer
     * silent return if UserInput::_begin_ == false
     * @param data a buffer with characters
     * @param len the size of the buffer
     * @param num_zdc size of CommandParameters zero delimiter command pointers array
     * @param zdc array of CommandParameters zero delimiter command pointers
     */
    void readCommandFromBuffer(uint8_t* data, size_t len, const size_t num_zdc = 0, const CommandParameters** zdc = NULL);

    #if defined(ENABLE_getCommandFromStream)
    /**
     * @brief Gets bytes from a Stream object and feeds a buffer to readCommandFromBuffer
     *
     * https://www.arduino.cc/reference/en/language/functions/communication/stream/
     *
     * silent return if UserInput::_begin_ == false
     * @param stream the stream to reference
     * @param rx_buffer_size the size of our receive buffer
     * @param num_zdc size of CommandParameters zero delimiter command pointers array
     * @param zdc array of CommandParameters zero delimiter command pointers
     */
    void getCommandFromStream(Stream&amp; stream, size_t rx_buffer_size = 32, const size_t num_zdc = 0, const CommandParameters** zdc = NULL);
    #endif

    #if defined(ENABLE_nextArgument)
    /**
     * @brief returns a pointer to the next token in UserInput::_token_buffer_ or NULL if there are no more tokens
     *
     * @return char*
     */
    char* nextArgument();
    #endif

    #if defined(ENABLE_getArgument)
    /**
     * @brief returns a pointer to argument_number token in UserInput::_token_buffer_ or NULL if there is no argument_number token
     *
     * @return char*
     */
    char* getArgument(size_t argument_number);
    #endif

    #if defined(ENABLE_outputIsAvailable)
    /**
     * @brief class output available if the return of this function is greater than zero
     * 
     * (True) if greater than 0 
     * (False) if 0
     *
     * @return the number of bytes available for output, or zero if there is no output     
     */
    size_t outputIsAvailable();
    #endif

    #if defined(ENABLE_outputIsEnabled)
    /**
     * @brief is class output enabled
     *
     * @return true if enabled
     * @return false if not enabled
     */
    bool outputIsEnabled();
    #endif

    #if defined(ENABLE_outputToStream)
    /**
     * @brief direct class output to stream, clears output buffer automatically
     *
     * @param stream the stream to print to
     */
    void outputToStream(Stream&amp; stream);
    #endif

    /**
     * @brief clears output buffer
     *
     * @param overwrite_contents boolean switch, clearOutputBuffer(true) writes null to entire _output_buffer_
     */
    void clearOutputBuffer(bool overwrite_contents = false);

    /**
     * @brief UserInput::getTokensParam UserInput::getTokens() parameters data structure
     */
    struct getTokensParam
    {
        uint8_t* data;                    ///&lt; pointer to uint8_t array
        size_t len;                       ///&lt; length of uint8_t array
        size_t data_pos;                  ///&lt; index of data
        char* token_buffer;               ///&lt; pointer to null terminated char array
        size_t token_buffer_len;          ///&lt; size of data + 1 + 1(if there are zero delim commands)
        size_t token_buffer_index;        ///&lt; index of token_buffer
        size_t num_token_ptrs;            ///&lt; token_pointers[MAX]
        uint8_t&amp; token_pointer_index;     ///&lt; index of token_pointers
        char** token_pointers;            ///&lt; array of token_buffer pointers
        bool point_to_beginning_of_token; ///&lt; assign pointer to &amp;token_buffer[token_buffer_index] if true
        char&amp; token_buffer_sep;           ///&lt; token_buffer token delimiter
    };

    /**
     * @brief puts tokens into the token buffer pointed to in getTokensParam
     *
     * @param gtprm UserInput::getTokensParam struct reference
     * @param input_prm reference to InputProcessParameters struct
     *
     * @return size_t number of tokens retrieved
     */
    size_t getTokens(getTokensParam&amp; gtprm, const InputProcessParameters&amp; input_prm);

    /**
     * @brief validateNullSepInputParam struct
     *
     */
    struct validateNullSepInputParam
    {
        UITYPE arg_type;            ///&lt; the UITYPE to test
        char** token_pointers;      ///&lt; pointers to null separated tokens
        size_t token_pointer_index; ///&lt; index of token_pointers to test
        char&amp; neg_sign;             ///&lt; single char neg sign, if different than &#39;-&#39; parseInt and the like will not assign your input negative
        char&amp; float_sep;            ///&lt; whole and fraction separator
    };

    /**
     * @brief Tries to determine if input is valid in NULL TERMINATED char arrays
     *
     * @param vprm validateNullSepInputParam struct reference
     *
     * @return true argument-type is valid
     * @return false argument-type is not valid
     */
    bool validateNullSepInput(validateNullSepInputParam&amp; vprm);

protected:
    /**
     * @brief transform 2d matrix indices to flat array index
     *
     * use this to access a dynamically allocated array like a 2d matrix,
     * this is much more performant than looping to allocate a (n&gt;1)d array,
     * and looping again to free allocated ram.
     *
     * @param m_width width of the matrix
     * @param row row you want to access
     * @param col column you want to access
     * @return size_t the transformed index
     */
    size_t mIndex(size_t m_width, size_t row, size_t col) const
    {
        return row + m_width * col;
    }

private:
    /*
        UserInput Constructor variables
    */

    // (potentially) user entered constructor variables
    char* _output_buffer_;                         ///&lt; pointer to the output char buffer
    size_t _output_buffer_len_;                    ///&lt; _output_buffer_ size in bytes
    const InputProcessParameters* _input_prm_ptr_; ///&lt; user input constructor parameters pointer
    // end user entered constructor variables

    bool _output_enabled_;             ///&lt; true if _output_buffer_ is not NULL (the user has defined and passed an output buffer to UserInput&#39;s constructor)
    size_t _output_buffer_bytes_left_; ///&lt; index of _output_buffer_, messages are appended to the output buffer and this keeps track of where to write to next without overwriting

    uint8_t _term_len_;   ///&lt; _term_ length in characters, determined in begin()
    uint8_t _term_index_; ///&lt; _term_ index, match all characters in term or reject the message

    void (*_default_function_)(UserInput*); ///&lt; pointer to the default function

    // linked-list
    CommandConstructor* _commands_head_; ///&lt; pointer to object list
    CommandConstructor* _commands_tail_; ///&lt; pointer to object list
    // end linked-list

    IH::ui_max_commands_in_tree_t _commands_count_;            ///&lt; how many commands are there
    IH::ui_max_tree_depth_per_command_t _max_depth_;           ///&lt; max command depth found
    IH::ui_max_args_t _max_args_;                              ///&lt; max command or subcommand arguments found
    IH::input_type_match_flags_type* _input_type_match_flags_; ///&lt; bool array _input_type_match_flags_[_max_args_]

    bool _output_flag_; ///&lt; output is available flag, set by member functions

    char* _token_buffer_;                        ///&lt; pointer to tokenized c-string
    char** _data_pointers_;                      ///&lt; token_buffer pointers
    IH::ui_max_args_t _data_pointers_index_;     ///&lt; data_pointer index
    IH::ui_max_args_t _data_pointers_index_max_; ///&lt; data_pointer index max
    IH::ui_max_args_t _p_num_ptrs_;              ///&lt; &quot;p&quot;rocess number of pointers, computed in UserInput::begin()

    IH::ui_max_args_t _rec_num_arg_strings_;                    ///&lt; number of tokens after first valid token
    IH::ui_max_num_child_commands_t _failed_on_subcommand_;     ///&lt; subcommand error index
    IH::ui_max_tree_depth_per_command_t _current_search_depth_; ///&lt; current subcommand search depth

    char _null_; ///&lt; char &#39;\0&#39;
    char _neg_;  ///&lt; char &#39;-&#39;
    char _dot_;  ///&lt; char &#39;.&#39;

    bool _stream_buffer_allocated_; ///&lt; this flag is set true on GetCommandFromStream entry if a buffer is not allocated
    bool _new_stream_data_;         ///&lt; if there is new data in *stream_data this is true
    uint8_t* _stream_data_;         ///&lt; pointer to stream input, a string of char
    uint16_t _stream_data_index_;   ///&lt; the index of stream_data

    bool _begin_; ///&lt; begin() error flag

    InputProcessParameters _input_prm_; ///&lt; user input process parameters pointer struct

    //  end constructor initialized variables

    // private methods
    /**
     * @brief UserInput vsnprintf
     * https://www.cplusplus.com/reference/cstdio/vsprintf/
     * @param fmt   the format string
     * @param ...   arguments
     */
    void _ui_out(const char* fmt, ...);

    #if defined(ENABLE_readCommandFromBufferErrorOutput)
    /**
     * @brief ReadCommandFromBuffer error output
     *
     * @param rprm reference to UserInput::_rcfbprm
     */
    void _readCommandFromBufferErrorOutput(_rcfbprm&amp; rprm);
    #endif // end ENABLE_readCommandFromBufferErrorOutput

    /**
     * @brief launches either (this) function or the root command function
     *
     * @param rprm reference to UserInput::_rcfbprm
     * @param pname IH_pname char array
     */
    void _launchFunction(_rcfbprm&amp; rprm, const IH_pname&amp; pname);

    /**
     * @brief function launch logic, recursive on subcommand match
     *
     * @param rprm reference to UserInput::_rcfbprm
     */
    void _launchLogic(_rcfbprm&amp; rprm);

    /**
     * @brief Escapes control characters so they will print
     *
     * @param input the input char
     * @param buf the output buffer
     *
     * @return pointer to buf, so you can use this inside of _ui_out()
     */
    char* _escapeCharactersSoTheyPrint(char input, char* buf);

    /**
     * @brief Triggers on a control character sequence, if the char immediately
     * after the control char is a char known to UserInput::_combineControlCharacters
     * this returns a control char, else it returns the input char
     *
     * @param input the char the control character sequence
     * @return the control character char value ie &#39;\\r&#39;
     */
    char _combineControlCharacters(char input);

    /**
     * @brief determines if input CommandParameters struct is valid before adding to linked-list
     *
     * @param cmd CommandConstructor reference
     * @param prm reference to CommandParameters struct in addCommand
     * @return true if there are no errors
     * @return false if there were one or more errors
     */
    bool _addCommandAbort(CommandConstructor&amp; cmd, CommandParameters&amp; prm);

    /**
     * @brief Get the UITYPE equivalent for the argument, internally we use uint8_t
     *
     * @param prm command options structure reference
     * @param index argument number
     * @return UITYPE argument type
     */
    UITYPE _getArgType(CommandParameters&amp; prm, size_t index = 0);

    /**
     * @brief validate the arguments as specified in the user defined CommandParameters struct
     *
     * @param rprm reference to UserInput::_rcfbprm
     */
    void _getArgs(_rcfbprm&amp; rprm);

    /**
     * @brief adds escaped control characters to a buffer
     *
     * @param buf output buffer
     * @param idx buffer index
     * @param input string to escape
     * @param input_len length of string
     * @return pointer to null terminated escaped control char string
     */
    char* _addEscapedControlCharToBuffer(char* buf, size_t&amp; idx, const char* input, size_t input_len);

    /**
     * @brief find delimiters in input data
     *
     * @param gtprm reference to getTokensParam struct in getTokens
     * @param input_prm reference to InputProcessParameters struct
     */
    void _getTokensDelimiters(getTokensParam&amp; gtprm, const InputProcessParameters&amp; input_prm);

    /**
     * @brief get delimited c-strings from input data
     *
     * @param gtprm reference to getTokensParam struct in getTokens
     * @param input_prm reference to InputProcessParameters struct
     */
    void _getTokensStartStop(getTokensParam&amp; gtprm, const InputProcessParameters&amp; input_prm);

    /**
     * @brief add uchar to token_buffer
     *
     * @param gtprm reference to getTokensParam struct in getTokens
     * @param input_prm reference to InputProcessParameters struct
     */
    void _getTokensChar(getTokensParam&amp; gtprm, const InputProcessParameters&amp; input_prm);

    /**
     * @brief split a zero delimiter command, separate command and string with token delimiter for further processing
     *
     * @param rprm reference to UserInput::_rcfbprm
     * @param num_zdc zero delim commands
     * @param zdc num zdc
     * @return true if split
     * @return false no match no split
     */
    bool _splitZDC(_rcfbprm&amp; rprm, const size_t num_zdc, const CommandParameters** zdc);

    /**
     * @brief calculates memcmp ranges for a given command around wildcard char, noninclusive
     *
     * @param command reference to a CommandConstructor class
     * @param prm reference to a CommandParameters struct
     * @param prm_idx prm index
     * @param memcmp_ranges_idx index of memcmp_ranges
     * @param memcmp_ranges memcmp ranges array
     */
    void _calcCmdMemcmpRanges(CommandConstructor&amp; command, CommandParameters&amp; prm, size_t prm_idx, IH::memcmp_idx_t&amp; memcmp_ranges_idx, IH::ui_max_per_cmd_memcmp_ranges_t* memcmp_ranges);

    /**
     * @brief compares (memcmp) str to cmd-&gt;prm[prm_idx].command
     *
     * @param cmd pointer to CommandConstructor
     * @param prm_idx index of CommandParameters to compare
     * @param str c-string
     * @return UI_COMPARE match type
     */
    UI_COMPARE _compareCommandToString(CommandConstructor* cmd, size_t prm_idx, char* str);
    // end private methods
};

#endif // header guard include

// end of file
</pre></div>
</div>
</div>
</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          
          <a class="prev-page" href="../src.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Source</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2022, Douglas Quigg (dquigg123@gmail.com)
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">InputHandler.h</a><ul>
<li><a class="reference internal" href="#id1">InputHandler.h</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <script src="../_static/scripts/furo.js"></script>
    </body>
</html>